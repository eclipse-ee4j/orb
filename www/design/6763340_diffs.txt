#
# Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Distribution License v. 1.0, which is available at
# http://www.eclipse.org/org/documents/edl-v10.php.
#
# SPDX-License-Identifier: BSD-3-Clause
#

Here are the differences that should fix 6763340.  I'll also include the full modified
ORB sources from JDK 1.6.0_14.  I also added code to CorbaClientRequestDispatcherImpl.beginRequest
to limit the maximum recursion, but I have not yet applied that change to the GFv3 ORB.

Also, all of the System.out.println code that we have added needs to be stripped out of the code.
I have added a lot of ORB debug code in the GFv3 version, but I have not attempted to
do that for the JDK version.

Fixes for 6763340:
    All changes are flagged with a comment containing the bug id:

spi/protocol/PIHandler.java:
    Add after invokeClientPIEndingPoint:

    /**
     * Called when a retry is needed after initiateClientPIRequest but 
     * before invokeClientPIRequest.  In this case, we need to properly
     * balance initiateClientPIRequest/cleanupClientPIRequest calls,
     * but WITHOUT extraneous calls to invokeClientPIEndingPoint
     * (see bug 6763340).
     *
     * @param replyStatus One of the constants in iiop.messages.ReplyMessage
     *     indicating which reply status to set.
     * @param exception The exception before ending interception points have
     *     been invoked, or null if no exception at the moment.
     * @return The exception to be thrown, after having gone through
     *     all ending points, or null if there is no exception to be
     *     thrown.  Note that this exception can be either the same or
     *     different from the exception set using setClientPIException.
     *     There are four possible return types: null (no exception),
     *     SystemException, UserException, or RemarshalException.
     */
    Exception makeCompletedClientRequest(
        int replyStatus, Exception exception ) ;

impl/orb/ORBImpl.java:
    Modify releaseOrDecrementInvocationInfo():

    public void releaseOrDecrementInvocationInfo() 
    {
        int entryCount = -1;
        ClientInvocationInfo clientInvocationInfo = null;
        try {
            if (subcontractDebugFlag) {
                dprint(".releaseOrDecrementInvocationInfo->:");
            }
            StackImpl invocationInfoStack =
                (StackImpl)clientInvocationInfoStack.get();
            if (!invocationInfoStack.empty()) {
                clientInvocationInfo =
                    (ClientInvocationInfo)invocationInfoStack.peek();
            } else {
                throw wrapper.invocationInfoStackEmpty() ;
            }
            clientInvocationInfo.decrementEntryCount();
            entryCount = clientInvocationInfo.getEntryCount();
            if (clientInvocationInfo.getEntryCount() == 0 
                // 6763340: don't pop if this is a retry!
                && !clientInvocationInfo.isRetryInvocation()) {

                invocationInfoStack.pop();
                if (subcontractDebugFlag) {
                    dprint(".releaseOrDecrementInvocationInfo: pop");
                }
            }
        } finally {
            if (subcontractDebugFlag) {
                dprint(".releaseOrDecrementInvocationInfo<-: entry count: "
                       + entryCount
                       + " " + clientInvocationInfo);
            }
        }
    }

impl/protocol/CorbaClientRequestDispatcherImpl:
    Modify beginRequest (this is just the catch (RemarshalException) clause.  This is the
    only recursive call in the GFv3 ORB, but the same fix is needed before the other
    recursive call to beginRequest in the JDK ORB):

            } catch( RemarshalException e ) {
                if (orb.subcontractDebugFlag) {
                    dputil.info( "Remarshal" ) ;
                }

                // NOTE: We get here because an interceptor raised ForwardRequest
                // and updated the IOR/Iterator.  Since we have a fresh iterator
                // hasNext should succeed.

                // REVISIT: We should feed ALL interceptor exceptions to 
                // iterator.reportException so it can determine if it wants
                // to retry.  Right now, SystemExceptions will flow to the
                // client code.

                // REVISIT:
                // This assumes that interceptors update
                // ContactInfoList outside of subcontract.
                // Want to move that update to here.
                if (getContactInfoListIterator(orb).hasNext()) {
                    contactInfo = (ContactInfo)getContactInfoListIterator(orb).next();
                    if (orb.subcontractDebugFlag) {
                        dputil.info( "RemarshalException: hasNext true", 
                            "contact info", contactInfo ) ;
                    }

                    // Fix for 6763340: Complete the first attempt before starting another.
                    orb.getPIHandler().makeCompletedClientRequest( 
                        ReplyMessage.LOCATION_FORWARD, null ) ;
                    orb.getPIHandler().cleanupClientPIRequest() ;

                    return beginRequest(self, opName, isOneWay, contactInfo);
                } else {
                    if (orb.subcontractDebugFlag) {
                        dputil.info( "RemarshalException: hasNext false" ) ;
                    }
                    ORBUtilSystemException wrapper = 
                        orb.getLogWrapperTable().get_RPC_PROTOCOL_ORBUtil() ; 
                    throw wrapper.remarshalWithNowhereToGo();
                }
            }

impl/interceptors/RequestInfoImpl.java:
    Modify reset method:

        void reset() {

        // Please keep these in the same order as declared above.

        flowStackIndex = 0;
        startingPointCall = 0;
        intermediatePointCall = 0;
        endingPointCall = 0;
        // 6763340
        setReplyStatus( UNINITIALIZED ) ;
        currentExecutionPoint = EXECUTION_POINT_STARTING;
        alreadyExecuted = false;
        connection = null;
        serviceContexts = null;
        forwardRequest = null;
        forwardRequestIOR = null;
        exception = null;

        // We don't need to reset the Slots because they are
        // already in the clean state after recieve_<point> interceptor
        // are called. 
    }

impl/interceptors/PIHandlerImpl.java:
    Replace invokeClientPIEndingPoint as follows:

    // Needed when an error forces a retry AFTER initiateClientPIRequest
    // but BEFORE invokeClientPIStartingPoint.
    public Exception makeCompletedClientRequest( int replyStatus,
        Exception exception ) {

        // 6763340
        return handleClientPIEndingPoint( replyStatus, exception, false ) ;
    }

    public Exception invokeClientPIEndingPoint( int replyStatus,
        Exception exception ) {

        // 6763340
        return handleClientPIEndingPoint( replyStatus, exception, true ) ;
    }

    public Exception handleClientPIEndingPoint(
        int replyStatus, Exception exception, boolean invokeEndingPoint ) {

        if (orb.interceptorDebugFlag) {
            dputil.enter( "handleClientPIEndingPoint", 
                "replyStatus", getReplyStatus(replyStatus), 
                "exception", exception, 
                "invokeEndingPoint", invokeEndingPoint ) ;
        }

        try {
            if( !hasClientInterceptors ) return exception;
            if( !isClientPIEnabledForThisThread() ) return exception;

            // Translate ReplyMessage.replyStatus into PI replyStatus:
            // Note: this is also an assertion to make sure a valid replyStatus
            // is passed in (IndexOutOfBoundsException will be thrown otherwise)
            short piReplyStatus = REPLY_MESSAGE_TO_PI_REPLY_STATUS[replyStatus];
            
            // Invoke the ending interception points and record exception
            // and reply status info in the info object:
            ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
            info.setReplyStatus( piReplyStatus );
            info.setException( exception );

            if (invokeEndingPoint) {
                // 6763340
                interceptorInvoker.invokeClientInterceptorEndingPoint( info );
                piReplyStatus = info.getReplyStatus();
            }

            // Check reply status:
            if( (piReplyStatus == LOCATION_FORWARD.value) ||
                (piReplyStatus == TRANSPORT_RETRY.value) ) {
                // If this is a forward or a retry, reset and reuse 
                // info object:
                info.reset();

                // fix for 6763340:
                if (invokeEndingPoint) {
                    info.setRetryRequest( RetryType.AFTER_RESPONSE ) ;
                } else {
                    info.setRetryRequest( RetryType.BEFORE_RESPONSE ) ;
                }

                // ... and return a RemarshalException so the orb internals know
                exception = new RemarshalException();
            } else if( (piReplyStatus == SYSTEM_EXCEPTION.value) ||
                     (piReplyStatus == USER_EXCEPTION.value) ) {

                exception = info.getException();
            }
            
            return exception;
        } finally {
            if (orb.interceptorDebugFlag) {
                dputil.exit() ;
            }
        }
    }

Replace initiateClientPIRequest as follows:

    public void initiateClientPIRequest( boolean diiRequest ) {
        if (orb.interceptorDebugFlag) {
            dputil.enter( "initiateClientPIRequest" ) ;
        }

        try {
            if( !hasClientInterceptors ) return;
            if( !isClientPIEnabledForThisThread() ) return;

            // Get the most recent info object from the thread local 
            // ClientRequestInfoImpl stack:
            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
                threadLocalClientRequestInfoStack.get();
            ClientRequestInfoImpl info = null;

            if (!infoStack.empty() ) {
                info = infoStack.peek();
            }

            if (!diiRequest && (info != null) && info.isDIIInitiate() ) {
                // In RequestImpl.doInvocation we already called 
                // initiateClientPIRequest( true ), so ignore this initiate.
                if (orb.interceptorDebugFlag) {
                    dputil.info( "second call for a DII request" ) ;
                }
                info.setDIIInitiate( false );
            } else {
                // If there is no info object or if we are not retrying a request,
                // push a new ClientRequestInfoImpl on the stack:
                if (orb.interceptorDebugFlag) {
                    dputil.info( "normal call" ) ;
                }

                // 6763340: don't push unless this is not a retry
                if( (info == null) || !info.getRetryRequest().isRetry() ) {
                    info = new ClientRequestInfoImpl( orb );
                    infoStack.push( info );
                    if (orb.interceptorDebugFlag) {
                        dputil.info( "client infoStack was pushed" ) ;
                    }
                    // Note: the entry count is automatically initialized to 0.
                }
                
                // Reset the retry request flag so that recursive calls will
                // push a new info object, and bump up entry count so we know
                // when to pop this info object:
                info.setRetryRequest( RetryType.NONE );
                info.incrementEntryCount();

                // KMC 6763340: I don't know why this wasn't set earlier,
                // but we do not want a retry to pick up the previous
                // reply status, so clear it here.  Most likely a new
                // info was pushed before, so that this was not a problem.
                info.setReplyStatus( RequestInfoImpl.UNINITIALIZED ) ;
                
                // If this is a DII request, make sure we ignore the next initiate.
                if( diiRequest ) {
                    info.setDIIInitiate( true );
                }
            }
        } finally {
            if (orb.interceptorDebugFlag) {
                dputil.exit() ;
            }
        }
    }

Replace cleanupClientPIRequest as follows:

    public void cleanupClientPIRequest() {
        if (orb.interceptorDebugFlag) {
            dputil.enter( "cleanupClientPIRequest" ) ;
        }

        try {
            if( !hasClientInterceptors ) return;
            if( !isClientPIEnabledForThisThread() ) return;

            ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
            RetryType rt = info.getRetryRequest() ;

            // fix for 6763340
            if (!rt.equals( RetryType.BEFORE_RESPONSE )) {
                // If the replyStatus has not yet been set, this is an indication
                // that the ORB threw an exception before we had a chance to
                // invoke the client interceptor ending points.
                //
                // _REVISIT_ We cannot handle any exceptions or ForwardRequests
                // flagged by the ending points here because there is no way
                // to gracefully handle this in any of the calling code.  
                // This is a rare corner case, so we will ignore this for now.
                short replyStatus = info.getReplyStatus();
                if (replyStatus == info.UNINITIALIZED ) {
                    invokeClientPIEndingPoint( ReplyMessage.SYSTEM_EXCEPTION,
                        wrapper.unknownRequestInvoke( 
                            CompletionStatus.COMPLETED_MAYBE ) ) ;
                }
            }
            
            // Decrement entry count, and if it is zero, pop it from the stack.
            info.decrementEntryCount();
            
            // fix for 6763340, and probably other cases (non-recursive retry)
            if (info.getEntryCount() == 0 && !info.getRetryRequest().isRetry()) {
                RequestInfoStack<ClientRequestInfoImpl> infoStack = 
                    threadLocalClientRequestInfoStack.get();
                infoStack.pop();
                if (orb.interceptorDebugFlag) {
                    dputil.info( "client infoStack was popped" ) ;
                }
            }
        } finally {
            if (orb.interceptorDebugFlag) {
                dputil.exit() ;
            }
        }
    }

impl/interceptors/ClientRequestInfoImpl:

Add import for com.sun.corba.ee.spi.protocol.RetryType

Change reset() as follows:

    void reset() {
        if (myORB.interceptorDebugFlag) {
            dputil.enter( "reset" ) ;
        }

        try {
            super.reset();

            // Please keep these in the same order that they're declared above.
            
            // 6763340
            retryRequest = RetryType.NONE;

            // Do not reset entryCount because we need to know when to pop this
            // from the stack.

            request = null;
            diiInitiate = false;
            messageMediator = null;

            // Clear cached attributes:
            cachedTargetObject = null;
            cachedEffectiveTargetObject = null;
            cachedArguments = null;
            cachedExceptions = null;
            cachedContexts = null;
            cachedOperationContext = null;
            cachedReceivedExceptionId = null;
            cachedResult = null;
            cachedReceivedException = null;
            cachedEffectiveProfile = null;
            cachedRequestServiceContexts = null;
            cachedReplyServiceContexts = null;
            cachedEffectiveComponents = null;

            piCurrentPushed = false;

            startingPointCall = CALL_SEND_REQUEST;
            endingPointCall = CALL_RECEIVE_REPLY;

        } finally {
            if (myORB.interceptorDebugFlag) {
                dputil.exit() ;
            }
        }
    }

Change set/getRetryRequest as follows:

    /**
     * Set or reset the retry request flag.  
     */
    void setRetryRequest( RetryType retryRequest ) {
        // 6763340
        this.retryRequest = retryRequest;
    }
    
    /**
     * Retrieve the current retry request status.
     */
    RetryType getRetryRequest() {
        // 6763340
        return this.retryRequest;
    }

Add new enum type to com/sun/corba/ee/spi/protocol/RetryType.java (new class) (with appropriate header):

package com.sun.corba.ee.spi.protocol ;

// Introduce more information about WHY we are re-trying a request
// so we can properly handle the two cases:
// - BEFORE_RESPONSE means that the retry is caused by 
//   something that happened BEFORE the message was sent: either 
//   an exception from the SocketFactory, or one from the 
//   Client side send_request interceptor point.
// - AFTER_RESPONSE means that the retry is a result either of the
//   request sent to the server (from the response), or from the
//   Client side receive_xxx interceptor point.
public enum RetryType { 
    NONE( false ),
    BEFORE_RESPONSE( true ),
    AFTER_RESPONSE( true ) ;

    private final boolean isRetry ;

    RetryType( boolean isRetry ) {
        this.isRetry = isRetry ;
    }

    public boolean isRetry() {
        return this.isRetry ;
    }
} ;


================================================

diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/encoding/CDROutputStream_1_0.java
--- a/src/share/classes/com/sun/corba/ee/impl/encoding/CDROutputStream_1_0.java Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/encoding/CDROutputStream_1_0.java Mon Jul 06 12:05:55 2009 -0700
@@ -209,18 +209,8 @@
 
     private final void createRepositoryIdHandlers()
     {
-        if (orb != null) {
-            // Get the appropriate versions based on the ORB version.  The
-            // ORB versioning info is only in the core ORB.
-            repIdUtil 
-                = RepositoryIdFactory.getRepIdUtility(orb);
-            repIdStrs 
-                = RepositoryIdFactory.getRepIdStringsFactory(orb);
-        } else {
-            // Get the latest versions
-            repIdUtil = RepositoryIdFactory.getRepIdUtility();
-            repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
-        }
+        repIdUtil = RepositoryIdFactory.getRepIdUtility();
+        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
     }
 
     public BufferManagerWrite getBufferManager()
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/interceptors/ClientRequestInfoImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/interceptors/ClientRequestInfoImpl.java   Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/interceptors/ClientRequestInfoImpl.java   Mon Jul 06 12:05:55 2009 -0700
@@ -41,36 +41,22 @@
 
 import org.omg.CORBA.Any;
 import org.omg.CORBA.BAD_INV_ORDER;
-import org.omg.CORBA.BAD_PARAM;
-import org.omg.CORBA.CompletionStatus;
 import org.omg.CORBA.Context;
 import org.omg.CORBA.ContextList;
 import org.omg.CORBA.CTX_RESTRICT_SCOPE;
 import org.omg.CORBA.ExceptionList;
-import org.omg.CORBA.LocalObject;
 import org.omg.CORBA.NamedValue;
-import org.omg.CORBA.NO_IMPLEMENT;
-import org.omg.CORBA.NO_RESOURCES;
 import org.omg.CORBA.NVList;
 import org.omg.CORBA.Object;
-import org.omg.CORBA.ParameterMode;
 import org.omg.CORBA.Policy;
 import org.omg.CORBA.SystemException;
 import org.omg.CORBA.TypeCode;
-import org.omg.CORBA.INTERNAL;
-import org.omg.CORBA.UserException;
 import org.omg.CORBA.portable.ApplicationException;
-import org.omg.CORBA.portable.InputStream;
 import com.sun.corba.ee.spi.servicecontext.ServiceContexts;
-import com.sun.corba.ee.spi.servicecontext.UnknownServiceContext;
 
 import org.omg.IOP.ServiceContext;
-import org.omg.IOP.ServiceContextHelper;
 import org.omg.IOP.TaggedProfile;
-import org.omg.IOP.TaggedProfileHelper;
 import org.omg.IOP.TaggedComponent;
-import org.omg.IOP.TaggedComponentHelper;
-import org.omg.IOP.TAG_INTERNET_IOP;
 import org.omg.Dynamic.Parameter;
 import org.omg.PortableInterceptor.ClientRequestInfo;
 import org.omg.PortableInterceptor.LOCATION_FORWARD;
@@ -83,18 +69,15 @@
 
 import com.sun.corba.ee.spi.ior.IOR;
 import com.sun.corba.ee.spi.ior.iiop.IIOPProfileTemplate;
-import com.sun.corba.ee.spi.ior.iiop.GIOPVersion;
 import com.sun.corba.ee.spi.orb.ORB;
 import com.sun.corba.ee.spi.protocol.CorbaMessageMediator;
+import com.sun.corba.ee.spi.protocol.RetryType;
 import com.sun.corba.ee.spi.transport.CorbaContactInfo;
 import com.sun.corba.ee.spi.transport.CorbaContactInfoList;
 import com.sun.corba.ee.spi.transport.CorbaContactInfoListIterator;
 
-import com.sun.corba.ee.impl.encoding.CDROutputStream;
-import com.sun.corba.ee.impl.encoding.CDRInputStream_1_0;
 import com.sun.corba.ee.impl.orbutil.ORBUtility;
 import com.sun.corba.ee.impl.protocol.CorbaInvocationInfo;
-import com.sun.corba.ee.impl.util.RepositoryId;
 
 /**
  * Implementation of the ClientRequestInfo interface as specified in
@@ -122,7 +105,7 @@
     
     // The current retry request status.  True if this request is being 
     // retried and this info object is to be reused, or false otherwise.
-    private boolean retryRequest;
+    private RetryType retryRequest;
     
     // The number of times this info object has been (re)used.  This is
     // incremented every time a request is retried, and decremented every
@@ -168,40 +151,51 @@
      * Reset the info object so that it can be reused for a retry,
      * for example.
      */
+    @Override
     void reset() {
-        super.reset();
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "reset" ) ;
+        }
 
-       // Please keep these in the same order that they're declared above.
-        
-        retryRequest = false;
+        try {
+            super.reset();
 
-        // Do not reset entryCount because we need to know when to pop this
-        // from the stack.
+            // Please keep these in the same order that they're declared above.
+            
+            retryRequest = RetryType.NONE;
 
-        request = null;
-       diiInitiate = false;
-       messageMediator = null;
+            // Do not reset entryCount because we need to know when to pop this
+            // from the stack.
 
-       // Clear cached attributes:
-       cachedTargetObject = null;
-       cachedEffectiveTargetObject = null;
-       cachedArguments = null;
-       cachedExceptions = null;
-       cachedContexts = null;
-       cachedOperationContext = null;
-       cachedReceivedExceptionId = null;
-       cachedResult = null;
-       cachedReceivedException = null;
-       cachedEffectiveProfile = null;
-       cachedRequestServiceContexts = null;
-       cachedReplyServiceContexts = null;
-        cachedEffectiveComponents = null;
+            request = null;
+            diiInitiate = false;
+            messageMediator = null;
 
-       piCurrentPushed = false;
+            // Clear cached attributes:
+            cachedTargetObject = null;
+            cachedEffectiveTargetObject = null;
+            cachedArguments = null;
+            cachedExceptions = null;
+            cachedContexts = null;
+            cachedOperationContext = null;
+            cachedReceivedExceptionId = null;
+            cachedResult = null;
+            cachedReceivedException = null;
+            cachedEffectiveProfile = null;
+            cachedRequestServiceContexts = null;
+            cachedReplyServiceContexts = null;
+            cachedEffectiveComponents = null;
 
-        startingPointCall = CALL_SEND_REQUEST;
-        endingPointCall = CALL_RECEIVE_REPLY;
+            piCurrentPushed = false;
 
+            startingPointCall = CALL_SEND_REQUEST;
+            endingPointCall = CALL_RECEIVE_REPLY;
+
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /*
@@ -286,15 +280,25 @@
      * The object which the client called to perform the operation.
      */
     public org.omg.CORBA.Object target (){
-       // access is currently valid for all states:
-        //checkAccess( MID_TARGET );
-       if (cachedTargetObject == null) {
-           CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
-               messageMediator.getContactInfo();
-           cachedTargetObject =
-               iorToObject(corbaContactInfo.getTargetIOR());
-       }
-       return cachedTargetObject;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "target" ) ;
+        }
+
+        try {
+            // access is currently valid for all states:
+            //checkAccess( MID_TARGET );
+            if (cachedTargetObject == null) {
+                CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
+                    messageMediator.getContactInfo();
+                cachedTargetObject =
+                    iorToObject(corbaContactInfo.getTargetIOR());
+            }
+            return cachedTargetObject;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -304,21 +308,31 @@
      * remain unchanged.  
      */
     public org.omg.CORBA.Object effective_target() {
-       // access is currently valid for all states:
-        //checkAccess( MID_EFFECTIVE_TARGET );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "effective_target" ) ;
+        }
 
-        // Note: This is not necessarily the same as locatedIOR.
-        // Reason: See the way we handle COMM_FAILURES in 
-        // ClientRequestDispatcher.createRequest, v1.32
+        try {
+            // access is currently valid for all states:
+            //checkAccess( MID_EFFECTIVE_TARGET );
 
-       if (cachedEffectiveTargetObject == null) {
-           CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
-               messageMediator.getContactInfo();
-           // REVISIT - get through chain like getLocatedIOR helper below.
-           cachedEffectiveTargetObject =
-               iorToObject(corbaContactInfo.getEffectiveTargetIOR());
-       }
-       return cachedEffectiveTargetObject;
+            // Note: This is not necessarily the same as locatedIOR.
+            // Reason: See the way we handle COMM_FAILURES in 
+            // ClientRequestDispatcher.createRequest, v1.32
+
+            if (cachedEffectiveTargetObject == null) {
+                CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
+                    messageMediator.getContactInfo();
+                // REVISIT - get through chain like getLocatedIOR helper below.
+                cachedEffectiveTargetObject =
+                    iorToObject(corbaContactInfo.getEffectiveTargetIOR());
+            }
+            return cachedEffectiveTargetObject;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -328,68 +342,98 @@
      * profile.
      */
     public TaggedProfile effective_profile (){
-        // access is currently valid for all states:
-        //checkAccess( MID_EFFECTIVE_PROFILE );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "effective_profile" ) ;
+        }
 
-       if( cachedEffectiveProfile == null ) {
-           CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
-               messageMediator.getContactInfo();
-           cachedEffectiveProfile =
-               corbaContactInfo.getEffectiveProfile().getIOPProfile();
-       }
+        try {
+            // access is currently valid for all states:
+            //checkAccess( MID_EFFECTIVE_PROFILE );
 
-       // Good citizen: In the interest of efficiency, we assume interceptors
-       // will not modify the returned TaggedProfile in any way so we need
-       // not make a deep copy of it.
+            if( cachedEffectiveProfile == null ) {
+                CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
+                    messageMediator.getContactInfo();
+                cachedEffectiveProfile =
+                    corbaContactInfo.getEffectiveProfile().getIOPProfile();
+            }
 
-       return cachedEffectiveProfile;
+            // Good citizen: In the interest of efficiency, we assume interceptors
+            // will not modify the returned TaggedProfile in any way so we need
+            // not make a deep copy of it.
+
+            return cachedEffectiveProfile;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * Contains the exception to be returned to the client.
      */
     public Any received_exception (){
-        checkAccess( MID_RECEIVED_EXCEPTION );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "received_exception" ) ;
+        }
 
-       if( cachedReceivedException == null ) {
-           cachedReceivedException = exceptionToAny( exception );
-       }
+        try {
+            checkAccess( MID_RECEIVED_EXCEPTION );
 
-       // Good citizen: In the interest of efficiency, we assume interceptors
-       // will not modify the returned Any in any way so we need
-       // not make a deep copy of it.
+            if( cachedReceivedException == null ) {
+                cachedReceivedException = exceptionToAny( exception );
+            }
 
-       return cachedReceivedException;
+            // Good citizen: In the interest of efficiency, we assume interceptors
+            // will not modify the returned Any in any way so we need
+            // not make a deep copy of it.
+
+            return cachedReceivedException;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * The CORBA::RepositoryId of the exception to be returned to the client.
      */
     public String received_exception_id (){
-        checkAccess( MID_RECEIVED_EXCEPTION_ID );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "received_exception_id" ) ;
+        }
 
-       if( cachedReceivedExceptionId == null ) {
-           String result = null;
-           
-           if( exception == null ) {
-               // Note: exception should never be null here since we will 
-               // throw a BAD_INV_ORDER if this is not called from 
-               // receive_exception.
-               throw wrapper.exceptionWasNull() ;
-           } else if( exception instanceof SystemException ) {
-               String name = exception.getClass().getName();
-               result = ORBUtility.repositoryIdOf(name);
-           } else if( exception instanceof ApplicationException ) {
-               result = ((ApplicationException)exception).getId();
-           }
+        try {
+            checkAccess( MID_RECEIVED_EXCEPTION_ID );
 
-           // _REVISIT_ We need to be able to handle a UserException in the 
-           // DII case.  How do we extract the ID from a UserException?
-           
-           cachedReceivedExceptionId = result;
-       }
+            if( cachedReceivedExceptionId == null ) {
+                String result = null;
+                
+                if( exception == null ) {
+                    // Note: exception should never be null here since we will 
+                    // throw a BAD_INV_ORDER if this is not called from 
+                    // receive_exception.
+                    throw wrapper.exceptionWasNull() ;
+                } else if( exception instanceof SystemException ) {
+                    String name = exception.getClass().getName();
+                    result = ORBUtility.repositoryIdOf(name);
+                } else if( exception instanceof ApplicationException ) {
+                    result = ((ApplicationException)exception).getId();
+                }
 
-       return cachedReceivedExceptionId;
+                // _REVISIT_ We need to be able to handle a UserException in the 
+                // DII case.  How do we extract the ID from a UserException?
+                
+                cachedReceivedExceptionId = result;
+            }
+
+            return cachedReceivedExceptionId;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -399,9 +443,19 @@
      * returns (get_effective_component should be called instead).
      */
     public TaggedComponent get_effective_component (int id){
-        checkAccess( MID_GET_EFFECTIVE_COMPONENT );
-        
-        return get_effective_components( id )[0];
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "get_effective_component" ) ;
+        }
+
+        try {
+            checkAccess( MID_GET_EFFECTIVE_COMPONENT );
+            
+            return get_effective_components( id )[0];
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -409,54 +463,74 @@
      * selected for this request.
      */
     public TaggedComponent[] get_effective_components (int id){
-        checkAccess( MID_GET_EFFECTIVE_COMPONENTS );
-       TaggedComponent[] result = null;
-       boolean justCreatedCache = false;
-
-       if( cachedEffectiveComponents == null ) {
-           cachedEffectiveComponents = new HashMap<Integer,TaggedComponent[]>();
-           justCreatedCache = true;
-       } else {
-           // Look in cache:
-           result = cachedEffectiveComponents.get( id );
-       }
-        
-       // null could mean we cached null or not in cache.
-       if( (result == null) &&
-           (justCreatedCache ||
-           !cachedEffectiveComponents.containsKey( id ) ) )
-       {
-           // Not in cache.  Get it from the profile:
-           CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
-               messageMediator.getContactInfo();
-           IIOPProfileTemplate ptemp = 
-               (IIOPProfileTemplate)corbaContactInfo.getEffectiveProfile().
-               getTaggedProfileTemplate();
-           result = ptemp.getIOPComponents(myORB, id);
-           cachedEffectiveComponents.put( id, result );
-       }
-        
-        // As per ptc/00-08-06, section 21.3.13.6., If not found, raise 
-        // BAD_PARAM with minor code INVALID_COMPONENT_ID.
-        if( (result == null) || (result.length == 0) ) {
-           throw stdWrapper.invalidComponentId( id ) ;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "get_effective_components" ) ;
         }
 
-       // Good citizen: In the interest of efficiency, we will assume 
-       // interceptors will not modify the returned TaggedCompoent[], or
-       // the TaggedComponents inside of it.  Otherwise, we would need to
-       // clone the array and make a deep copy of its contents.
-        
-        return result;
+        try {
+            checkAccess( MID_GET_EFFECTIVE_COMPONENTS );
+            TaggedComponent[] result = null;
+            boolean justCreatedCache = false;
+
+            if( cachedEffectiveComponents == null ) {
+                cachedEffectiveComponents = new HashMap<Integer,TaggedComponent[]>();
+                justCreatedCache = true;
+            } else {
+                // Look in cache:
+                result = cachedEffectiveComponents.get( id );
+            }
+            
+            // null could mean we cached null or not in cache.
+            if( (result == null) &&
+                (justCreatedCache ||
+                !cachedEffectiveComponents.containsKey( id ) ) )
+            {
+                // Not in cache.  Get it from the profile:
+                CorbaContactInfo corbaContactInfo = (CorbaContactInfo)
+                    messageMediator.getContactInfo();
+                IIOPProfileTemplate ptemp = 
+                    (IIOPProfileTemplate)corbaContactInfo.getEffectiveProfile().
+                    getTaggedProfileTemplate();
+                result = ptemp.getIOPComponents(myORB, id);
+                cachedEffectiveComponents.put( id, result );
+            }
+            
+            // As per ptc/00-08-06, section 21.3.13.6., If not found, raise 
+            // BAD_PARAM with minor code INVALID_COMPONENT_ID.
+            if( (result == null) || (result.length == 0) ) {
+                throw stdWrapper.invalidComponentId( id ) ;
+            }
+
+            // Good citizen: In the interest of efficiency, we will assume 
+            // interceptors will not modify the returned TaggedCompoent[], or
+            // the TaggedComponents inside of it.  Otherwise, we would need to
+            // clone the array and make a deep copy of its contents.
+            
+            return result;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * Returns the given policy in effect for this operation.
      */
     public Policy get_request_policy (int type){
-        checkAccess( MID_GET_REQUEST_POLICY );
-       // _REVISIT_ Our ORB is not policy-based at this time.
-       throw wrapper.piOrbNotPolicyBased() ;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "get_request_policy" ) ;
+        }
+
+        try {
+            checkAccess( MID_GET_REQUEST_POLICY );
+            // _REVISIT_ Our ORB is not policy-based at this time.
+            throw wrapper.piOrbNotPolicyBased() ;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -468,16 +542,26 @@
     public void add_request_service_context (ServiceContext service_context, 
                                              boolean replace)
     {
-        checkAccess( MID_ADD_REQUEST_SERVICE_CONTEXT );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "add_request_service_context" ) ;
+        }
 
-       if( cachedRequestServiceContexts == null ) {
-           cachedRequestServiceContexts = 
-               new HashMap<Integer,org.omg.IOP.ServiceContext>();
-       }
+        try {
+            checkAccess( MID_ADD_REQUEST_SERVICE_CONTEXT );
 
-       addServiceContext( cachedRequestServiceContexts, 
-                          messageMediator.getRequestServiceContexts(),
-                          service_context, replace );
+            if( cachedRequestServiceContexts == null ) {
+                cachedRequestServiceContexts = 
+                    new HashMap<Integer,org.omg.IOP.ServiceContext>();
+            }
+
+            addServiceContext( cachedRequestServiceContexts, 
+                               messageMediator.getRequestServiceContexts(),
+                               service_context, replace );
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     // NOTE: When adding a method, be sure to:
@@ -517,6 +601,7 @@
        return messageMediator.getOperationName();
     }
 
+    @Override
     public String toString() {
        return "ClientRequestInfoImpl[operation=" 
            + operation() + "]" ;
@@ -526,175 +611,225 @@
      * See RequestInfoImpl for javadoc.
      */
     public Parameter[] arguments (){
-        checkAccess( MID_ARGUMENTS );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "arguments" ) ;
+        }
 
-       if( cachedArguments == null ) {
-           if( request == null ) {
-               throw stdWrapper.piOperationNotSupported1() ;
-           }
+        try {
+            checkAccess( MID_ARGUMENTS );
 
-           // If it is DII request then get the arguments from the DII req
-           // and convert that into parameters.
-           cachedArguments = nvListToParameterArray( request.arguments() );
-       }
+            if( cachedArguments == null ) {
+                if( request == null ) {
+                    throw stdWrapper.piOperationNotSupported1() ;
+                }
 
-        // Good citizen: In the interest of efficiency, we assume 
-        // interceptors will be "good citizens" in that they will not 
-        // modify the contents of the Parameter[] array.  We also assume 
-        // they will not change the values of the containing Anys.
+                // If it is DII request then get the arguments from the DII req
+                // and convert that into parameters.
+                cachedArguments = nvListToParameterArray( request.arguments() );
+            }
 
-       return cachedArguments;
+            // Good citizen: In the interest of efficiency, we assume 
+            // interceptors will be "good citizens" in that they will not 
+            // modify the contents of the Parameter[] array.  We also assume 
+            // they will not change the values of the containing Anys.
+
+            return cachedArguments;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * See RequestInfoImpl for javadoc.
      */
     public TypeCode[] exceptions (){
-        checkAccess( MID_EXCEPTIONS );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "exceptions" ) ;
+        }
 
-       if( cachedExceptions == null ) {
-           if( request == null ) {
-              throw stdWrapper.piOperationNotSupported2() ;
-           }
+        try {
+            checkAccess( MID_EXCEPTIONS );
 
-           // Get the list of exceptions from DII request data, If there are
-           // no exceptions raised then this method will return null.
-           ExceptionList excList = request.exceptions( );
-           int count = excList.count();
-           TypeCode[] excTCList = new TypeCode[count];
-           try {
-               for( int i = 0; i < count; i++ ) {
-                   excTCList[i] = excList.item( i );
-               }
-           } catch( Exception e ) {
-               throw wrapper.exceptionInExceptions( e ) ;
-           }
+            if( cachedExceptions == null ) {
+                if( request == null ) {
+                   throw stdWrapper.piOperationNotSupported2() ;
+                }
 
-           cachedExceptions = excTCList;
-       }
+                // Get the list of exceptions from DII request data, If there are
+                // no exceptions raised then this method will return null.
+                ExceptionList excList = request.exceptions( );
+                int count = excList.count();
+                TypeCode[] excTCList = new TypeCode[count];
+                try {
+                    for( int i = 0; i < count; i++ ) {
+                        excTCList[i] = excList.item( i );
+                    }
+                } catch( Exception e ) {
+                    throw wrapper.exceptionInExceptions( e ) ;
+                }
 
-        // Good citizen: In the interest of efficiency, we assume 
-        // interceptors will be "good citizens" in that they will not 
-        // modify the contents of the TypeCode[] array.  We also assume 
-        // they will not change the values of the containing TypeCodes.
+                cachedExceptions = excTCList;
+            }
 
-       return cachedExceptions;
+            // Good citizen: In the interest of efficiency, we assume 
+            // interceptors will be "good citizens" in that they will not 
+            // modify the contents of the TypeCode[] array.  We also assume 
+            // they will not change the values of the containing TypeCodes.
+
+            return cachedExceptions;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * See RequestInfoImpl for javadoc.
      */
     public String[] contexts (){
-        checkAccess( MID_CONTEXTS );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "contexts" ) ;
+        }
 
-       if( cachedContexts == null ) {
-           if( request == null ) {
-               throw stdWrapper.piOperationNotSupported3() ;
-           }
+        try {
+            checkAccess( MID_CONTEXTS );
 
-           // Get the list of contexts from DII request data, If there are
-           // no contexts then this method will return null.
-           ContextList ctxList = request.contexts( );
-           int count = ctxList.count();
-           String[] ctxListToReturn = new String[count];
-           try {
-               for( int i = 0; i < count; i++ ) {
-                   ctxListToReturn[i] = ctxList.item( i );
-               }
-           } catch( Exception e ) {
-               throw wrapper.exceptionInContexts( e ) ;
-           }
+            if( cachedContexts == null ) {
+                if( request == null ) {
+                    throw stdWrapper.piOperationNotSupported3() ;
+                }
 
-            cachedContexts = ctxListToReturn;
-       }
+                // Get the list of contexts from DII request data, If there are
+                // no contexts then this method will return null.
+                ContextList ctxList = request.contexts( );
+                int count = ctxList.count();
+                String[] ctxListToReturn = new String[count];
+                try {
+                    for( int i = 0; i < count; i++ ) {
+                        ctxListToReturn[i] = ctxList.item( i );
+                    }
+                } catch( Exception e ) {
+                    throw wrapper.exceptionInContexts( e ) ;
+                }
 
-        // Good citizen: In the interest of efficiency, we assume 
-        // interceptors will be "good citizens" in that they will not 
-        // modify the contents of the String[] array.  
+                cachedContexts = ctxListToReturn;
+            }
 
-       return cachedContexts;
+            // Good citizen: In the interest of efficiency, we assume 
+            // interceptors will be "good citizens" in that they will not 
+            // modify the contents of the String[] array.  
+
+            return cachedContexts;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * See RequestInfoImpl for javadoc.
      */
     public String[] operation_context (){
-        checkAccess( MID_OPERATION_CONTEXT );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "operation_context" ) ;
+        }
 
-       if( cachedOperationContext == null ) {
-           if( request == null ) {
-               throw stdWrapper.piOperationNotSupported4() ;
-           }
+        try {
+            checkAccess( MID_OPERATION_CONTEXT );
 
-           // Get the list of contexts from DII request data, If there are
-           // no contexts then this method will return null.
-           Context ctx = request.ctx( );
-           // _REVISIT_ The API for get_values is not compliant with the spec,
-           // Revisit this code once it's fixed.
-           // _REVISIT_ Our ORB doesn't support Operation Context, This code
-           // will not be excerscised until it's supported.
-           // The first parameter in get_values is the start_scope which 
-           // if blank makes it as a global scope.
-           // The second parameter is op_flags which is set to RESTRICT_SCOPE
-           // As there is only one defined in the spec.
-           // The Third param is the pattern which is '*' requiring it to 
-           // get all the contexts.
-           NVList nvList = ctx.get_values( "", CTX_RESTRICT_SCOPE.value,"*" );
-           String[] context = new String[(nvList.count() * 2) ];
-           if( ( nvList != null ) &&( nvList.count() != 0 ) ) {
-               // The String[] array will contain Name and Value for each
-               // context and hence double the size in the array.
-               int index = 0;
-               for( int i = 0; i < nvList.count(); i++ ) {
-                   NamedValue nv;
-                   try {
-                       nv = nvList.item( i );
-                   }
-                   catch (Exception e ) {
-                       return (String[]) null;
-                   }
-                   context[index] = nv.name();
-                   index++;
-                   context[index] = nv.value().extract_string();
-                   index++;
-               }
-           }
+            if( cachedOperationContext == null ) {
+                if( request == null ) {
+                    throw stdWrapper.piOperationNotSupported4() ;
+                }
 
-           cachedOperationContext = context;
-       }
+                // Get the list of contexts from DII request data, If there are
+                // no contexts then this method will return null.
+                Context ctx = request.ctx( );
+                // _REVISIT_ The API for get_values is not compliant with the spec,
+                // Revisit this code once it's fixed.
+                // _REVISIT_ Our ORB doesn't support Operation Context, This code
+                // will not be excerscised until it's supported.
+                // The first parameter in get_values is the start_scope which 
+                // if blank makes it as a global scope.
+                // The second parameter is op_flags which is set to RESTRICT_SCOPE
+                // As there is only one defined in the spec.
+                // The Third param is the pattern which is '*' requiring it to 
+                // get all the contexts.
+                NVList nvList = ctx.get_values( "", CTX_RESTRICT_SCOPE.value,"*" );
+                String[] context = new String[(nvList.count() * 2) ];
+                if( ( nvList != null ) &&( nvList.count() != 0 ) ) {
+                    // The String[] array will contain Name and Value for each
+                    // context and hence double the size in the array.
+                    int index = 0;
+                    for( int i = 0; i < nvList.count(); i++ ) {
+                        NamedValue nv;
+                        try {
+                            nv = nvList.item( i );
+                        }
+                        catch (Exception e ) {
+                            return (String[]) null;
+                        }
+                        context[index] = nv.name();
+                        index++;
+                        context[index] = nv.value().extract_string();
+                        index++;
+                    }
+                }
 
-        // Good citizen: In the interest of efficiency, we assume 
-        // interceptors will be "good citizens" in that they will not 
-        // modify the contents of the String[] array.  
+                cachedOperationContext = context;
+            }
 
-       return cachedOperationContext;
+            // Good citizen: In the interest of efficiency, we assume 
+            // interceptors will be "good citizens" in that they will not 
+            // modify the contents of the String[] array.  
+
+            return cachedOperationContext;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * See RequestInfoImpl for javadoc.
      */
     public Any result (){
-        checkAccess( MID_RESULT );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "result" ) ;
+        }
 
-       if( cachedResult == null ) {
-           if( request == null ) {
-               throw stdWrapper.piOperationNotSupported5() ;
-           }
-           // Get the result from the DII request data.
-           NamedValue nvResult = request.result( );
+        try {
+            checkAccess( MID_RESULT );
 
-           if( nvResult == null ) {
-               throw wrapper.piDiiResultIsNull() ;
-           }
+            if( cachedResult == null ) {
+                if( request == null ) {
+                    throw stdWrapper.piOperationNotSupported5() ;
+                }
+                // Get the result from the DII request data.
+                NamedValue nvResult = request.result( );
 
-           cachedResult = nvResult.value();
-       }
+                if( nvResult == null ) {
+                    throw wrapper.piDiiResultIsNull() ;
+                }
 
-       // Good citizen: In the interest of efficiency, we assume that
-       // interceptors will not modify the contents of the result Any.
-       // Otherwise, we would need to create a deep copy of the Any.
+                cachedResult = nvResult.value();
+            }
 
-        return cachedResult;
+            // Good citizen: In the interest of efficiency, we assume that
+            // interceptors will not modify the contents of the result Any.
+            // Otherwise, we would need to create a deep copy of the Any.
+
+            return cachedResult;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
@@ -710,60 +845,99 @@
      * See RequestInfoImpl for javadoc.
      */
     public Object forward_reference (){
-        checkAccess( MID_FORWARD_REFERENCE );
-        // Check to make sure we are in LOCATION_FORWARD
-        // state as per ptc/00-08-06, table 21-1
-        // footnote 2.
-        if( replyStatus != LOCATION_FORWARD.value ) {
-           throw stdWrapper.invalidPiCall1() ;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "forward_reference" ) ;
         }
 
-       // Do not cache this value since if an interceptor raises
-       // forward request then the next interceptor in the
-       // list should see the new value.
-       IOR ior = getLocatedIOR();
-       return iorToObject(ior);
+        try {
+            checkAccess( MID_FORWARD_REFERENCE );
+            // Check to make sure we are in LOCATION_FORWARD
+            // state as per ptc/00-08-06, table 21-1
+            // footnote 2.
+            if( replyStatus != LOCATION_FORWARD.value ) {
+                throw stdWrapper.invalidPiCall1() ;
+            }
+
+            // Do not cache this value since if an interceptor raises
+            // forward request then the next interceptor in the
+            // list should see the new value.
+            IOR ior = getLocatedIOR();
+            return iorToObject(ior);
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    private IOR getLocatedIOR()
-    {
-       IOR ior;
-       CorbaContactInfoList contactInfoList = (CorbaContactInfoList)
-           messageMediator.getContactInfo().getContactInfoList();
-       ior = contactInfoList.getEffectiveTargetIOR();
-       return ior;
+    private IOR getLocatedIOR() {
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "getLocatedIOR" ) ;
+        }
+
+        try {
+            IOR ior;
+            CorbaContactInfoList contactInfoList = (CorbaContactInfoList)
+                messageMediator.getContactInfo().getContactInfoList();
+            ior = contactInfoList.getEffectiveTargetIOR();
+            return ior;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     // Used to be protected. public for IIOPFailoverManagerImpl.
-    public void setLocatedIOR(IOR ior)
-    {
-       ORB orb = (ORB) messageMediator.getBroker();
+    public void setLocatedIOR(IOR ior) {
 
-       CorbaContactInfoListIterator iterator = (CorbaContactInfoListIterator)
-           ((CorbaInvocationInfo)orb.getInvocationInfo())
-           .getContactInfoListIterator();
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "setLocatedIOR" ) ;
+        }
 
-       // REVISIT - this most likely causes reportRedirect to happen twice.
-       // Once here and once inside the request dispatcher.
-       iterator.reportRedirect(
-           (CorbaContactInfo)messageMediator.getContactInfo(),
-           ior);
+        try {
+            ORB orb = (ORB) messageMediator.getBroker();
+
+            CorbaContactInfoListIterator iterator = (CorbaContactInfoListIterator)
+                ((CorbaInvocationInfo)orb.getInvocationInfo())
+                .getContactInfoListIterator();
+
+            // REVISIT - this most likely causes reportRedirect to happen twice.
+            // Once here and once inside the request dispatcher.
+            iterator.reportRedirect(
+                (CorbaContactInfo)messageMediator.getContactInfo(),
+                ior);
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * See RequestInfoImpl for javadoc.
      */
     public org.omg.IOP.ServiceContext get_request_service_context( int id ) {
-        checkAccess( MID_GET_REQUEST_SERVICE_CONTEXT );
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "get_request_service_context" ) ;
+        }
 
-       if( cachedRequestServiceContexts == null ) {
-           cachedRequestServiceContexts = 
-               new HashMap<Integer,org.omg.IOP.ServiceContext>();
-       }
+        try {
+            checkAccess( MID_GET_REQUEST_SERVICE_CONTEXT );
 
-       return  getServiceContext(cachedRequestServiceContexts, 
-                                 messageMediator.getRequestServiceContexts(),
-                                 id);
+            if( cachedRequestServiceContexts == null ) {
+                cachedRequestServiceContexts = 
+                    new HashMap<Integer,org.omg.IOP.ServiceContext>();
+            }
+
+            return  getServiceContext(cachedRequestServiceContexts, 
+                                      messageMediator.getRequestServiceContexts(),
+                                      id);
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
@@ -771,35 +945,45 @@
      * TBD_BP is raised.
      */
     public org.omg.IOP.ServiceContext get_reply_service_context( int id ) {
-        checkAccess( MID_GET_REPLY_SERVICE_CONTEXT );       
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "get_reply_service_context" ) ;
+        }
 
-       if( cachedReplyServiceContexts == null ) {
-           cachedReplyServiceContexts = 
-               new HashMap<Integer,org.omg.IOP.ServiceContext>();
-       }
+        try {
+            checkAccess( MID_GET_REPLY_SERVICE_CONTEXT );       
 
-       // In the event this is called from a oneway, we will have no
-       // response object.
-       //
-       // In the event this is called after a IIOPConnection.purgeCalls,
-       // we will have a response object, but that object will
-       // not contain a header (which would hold the service context
-       // container).  See bug 4624102.
-       //
+            if( cachedReplyServiceContexts == null ) {
+                cachedReplyServiceContexts = 
+                    new HashMap<Integer,org.omg.IOP.ServiceContext>();
+            }
 
-       // REVISIT: getReplyHeader should not be visible here.
-       if (messageMediator.getReplyHeader() != null) {
-           ServiceContexts serviceContexts =
-               messageMediator.getReplyServiceContexts();
-           if (serviceContexts != null) {
-               return getServiceContext(cachedReplyServiceContexts,
-                                        serviceContexts, id);
-           }
-       }
-       // See purge calls test.  The waiter is woken up by the
-       // call to purge calls - but there is no reply containing
-       // service contexts.
-       throw stdWrapper.invalidServiceContextId() ;
+            // In the event this is called from a oneway, we will have no
+            // response object.
+            //
+            // In the event this is called after a IIOPConnection.purgeCalls,
+            // we will have a response object, but that object will
+            // not contain a header (which would hold the service context
+            // container).  See bug 4624102.
+            //
+
+            // REVISIT: getReplyHeader should not be visible here.
+            if (messageMediator.getReplyHeader() != null) {
+                ServiceContexts sctxs =
+                    messageMediator.getReplyServiceContexts();
+                if (sctxs != null) {
+                    return getServiceContext(cachedReplyServiceContexts,
+                                             sctxs, id);
+                }
+            }
+            // See purge calls test.  The waiter is woken up by the
+            // call to purge calls - but there is no reply containing
+            // service contexts.
+            throw stdWrapper.invalidServiceContextId() ;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     //
@@ -807,6 +991,7 @@
     // Override RequestInfoImpl connection to work in framework.
     //
 
+    @Override
     public com.sun.corba.ee.spi.legacy.connection.Connection connection()
     {
        return (com.sun.corba.ee.spi.legacy.connection.Connection) 
@@ -830,14 +1015,14 @@
     /**
      * Set or reset the retry request flag.  
      */
-    void setRetryRequest( boolean retryRequest ) {
+    void setRetryRequest( RetryType retryRequest ) {
         this.retryRequest = retryRequest;
     }
     
     /**
      * Retrieve the current retry request status.
      */
-    boolean getRetryRequest() {
+    RetryType getRetryRequest() {
         return this.retryRequest;
     }
     
@@ -845,42 +1030,109 @@
      * Increases the entry count by 1.
      */
     void incrementEntryCount() {
-        this.entryCount++;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "incrementEntryCount" ) ;
+        }
+
+        try {
+            this.entryCount++;
+            if (myORB.interceptorDebugFlag) {
+                dputil.info( "entryCount", this.entryCount ) ;
+            }
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * Decreases the entry count by 1.
      */
     void decrementEntryCount() {
-        this.entryCount--;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "decrementEntryCount" ) ;
+        }
+
+        try {
+            this.entryCount--;
+            if (myORB.interceptorDebugFlag) {
+                dputil.info( "entryCount", this.entryCount ) ;
+            }
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * Retrieve the current entry count
      */
     int getEntryCount() {
-        return this.entryCount;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "getEntryCount" ) ;
+        }
+
+        int result = 0 ;
+        try {
+            result = this.entryCount;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit( result ) ;
+            }
+        }
+        return result ;
     }
     
     /**
      * Overridden from RequestInfoImpl.  Calls the super class, then
      * sets the ending point call depending on the reply status.
      */
+    @Override
     protected void setReplyStatus( short replyStatus ) {
-        super.setReplyStatus( replyStatus );
-        switch( replyStatus ) {
-        case SUCCESSFUL.value:
-            endingPointCall = CALL_RECEIVE_REPLY;
-            break;
-        case SYSTEM_EXCEPTION.value:
-        case USER_EXCEPTION.value:
-            endingPointCall = CALL_RECEIVE_EXCEPTION;
-            break;
-        case LOCATION_FORWARD.value:
-        case TRANSPORT_RETRY.value:
-            endingPointCall = CALL_RECEIVE_OTHER;
-            break;
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "setReplyStatus", 
+                PIHandlerImpl.getReplyStatus(replyStatus) ) ;
         }
+        try {
+            super.setReplyStatus( replyStatus );
+            switch( replyStatus ) {
+            case SUCCESSFUL.value:
+                endingPointCall = CALL_RECEIVE_REPLY;
+                break;
+            case SYSTEM_EXCEPTION.value:
+            case USER_EXCEPTION.value:
+                endingPointCall = CALL_RECEIVE_EXCEPTION;
+                break;
+            case LOCATION_FORWARD.value:
+            case TRANSPORT_RETRY.value:
+                endingPointCall = CALL_RECEIVE_OTHER;
+                break;
+            }
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
+    }
+
+    @Override
+    protected short getReplyStatus() {
+        if (myORB.interceptorDebugFlag) {
+            dputil.enter( "getReplyStatus" ) ;
+        }
+
+        short result = 0 ;
+        try {
+            result = super.getReplyStatus() ;
+        } finally {
+            if (myORB.interceptorDebugFlag) {
+                dputil.exit( PIHandlerImpl.getReplyStatus( result ) ) ;
+            }
+        }
+        
+        return result ;
     }
 
     /**
@@ -923,6 +1175,7 @@
     /**
      * Overridden from RequestInfoImpl.
      */
+    @Override
     protected void setException( Exception exception ) {
         super.setException( exception );
 
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/interceptors/InterceptorInvoker.java
--- a/src/share/classes/com/sun/corba/ee/impl/interceptors/InterceptorInvoker.java      Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/interceptors/InterceptorInvoker.java      Mon Jul 06 12:05:55 2009 -0700
@@ -35,28 +35,20 @@
  */
 package com.sun.corba.ee.impl.interceptors;
 
-import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.INTERNAL;
 import org.omg.CORBA.SystemException;
-import org.omg.CORBA.portable.Delegate;
 import org.omg.PortableInterceptor.LOCATION_FORWARD;
-import org.omg.PortableInterceptor.SUCCESSFUL;
 import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;
-import org.omg.PortableInterceptor.TRANSPORT_RETRY;
-import org.omg.PortableInterceptor.USER_EXCEPTION;
-import org.omg.PortableInterceptor.ClientRequestInfo;
 import org.omg.PortableInterceptor.ClientRequestInterceptor;
 import org.omg.PortableInterceptor.ForwardRequest;
 import org.omg.PortableInterceptor.IORInterceptor;
 import org.omg.PortableInterceptor.IORInterceptor_3_0;
-import org.omg.PortableInterceptor.ServerRequestInfo;
 import org.omg.PortableInterceptor.ServerRequestInterceptor;
 import org.omg.PortableInterceptor.ObjectReferenceTemplate;
 
 import com.sun.corba.ee.spi.ior.IOR;
 import com.sun.corba.ee.spi.oa.ObjectAdapter;
 import com.sun.corba.ee.spi.orb.ORB;
-import com.sun.corba.ee.impl.orbutil.ORBUtility;
+import com.sun.corba.ee.impl.orbutil.DprintUtil;
         
 /** 
  * Handles invocation of interceptors.  Has specific knowledge of how to
@@ -69,7 +61,8 @@
 
     // The ORB
     private ORB orb;
-    
+    private DprintUtil dputil = new DprintUtil( this ) ;
+
     // The list of interceptors to be invoked
     private InterceptorList interceptorList;
 
@@ -99,10 +92,6 @@
         this.current = piCurrent;
     }
 
-    private void dprint( String msg ) {
-       ORBUtility.dprint( this, msg ) ;
-    }
-
     /**
      * Enables or disables the interceptor invoker
      */
@@ -121,100 +110,128 @@
      * @param oa The Object Adapter associated with the IOR interceptor.
      */
     void objectAdapterCreated( ObjectAdapter oa ) {
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled ) {
-           // Create IORInfo object to pass to IORInterceptors:
-           IORInfoImpl info = new IORInfoImpl( oa );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "objectAdapterCreated" ) ;
+        }
 
-           // Call each IORInterceptor:
-           IORInterceptor[] iorInterceptors = 
-                (IORInterceptor[])interceptorList.getInterceptors( 
-                InterceptorList.INTERCEPTOR_TYPE_IOR );
-           int size = iorInterceptors.length;
+        try {
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled ) {
+                // Create IORInfo object to pass to IORInterceptors:
+                IORInfoImpl info = new IORInfoImpl( oa );
 
-           // Implementation note:
-           // This loop counts backwards for greater efficiency.
-           // Benchmarks have shown that counting down is more efficient
-           // than counting up in Java for loops, as a compare to zero is
-           // faster than a subtract and compare to zero.  In this case,
-           // it doesn't really matter much, but it's simply a force of habit.
+                // Call each IORInterceptor:
+                IORInterceptor[] iorInterceptors = 
+                    (IORInterceptor[])interceptorList.getInterceptors( 
+                    InterceptorList.INTERCEPTOR_TYPE_IOR );
+                int size = iorInterceptors.length;
 
-           for( int i = (size - 1); i >= 0; i-- ) {
-               IORInterceptor interceptor = iorInterceptors[i];
-               try {
-                   interceptor.establish_components( info );
-               }
-               catch( Exception e ) {
-                   // as per PI spec (orbos/99-12-02 sec 7.2.1), if
-                   // establish_components throws an exception, ignore it.
-               }
-           }
+                // Implementation note:
+                // This loop counts backwards for greater efficiency.
+                // Benchmarks have shown that counting down is more efficient
+                // than counting up in Java for loops, as a compare to zero is
+                // faster than a subtract and compare to zero.  In this case,
+                // it doesn't really matter much, but it's simply a force of habit.
 
-           // Change the state so that only template operations are valid
-           info.makeStateEstablished() ;
+                for( int i = (size - 1); i >= 0; i-- ) {
+                    IORInterceptor interceptor = iorInterceptors[i];
+                    try {
+                        interceptor.establish_components( info );
+                    }
+                    catch( Exception e ) {
+                        // as per PI spec (orbos/99-12-02 sec 7.2.1), if
+                        // establish_components throws an exception, ignore it.
+                    }
+                }
 
-           for( int i = (size - 1); i >= 0; i-- ) {
-               IORInterceptor interceptor = iorInterceptors[i];
-               if (interceptor instanceof IORInterceptor_3_0) {
-                   IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
-                   // Note that exceptions here are NOT ignored, as per the
-                   // ORT spec (orbos/01-01-04)
-                   interceptor30.components_established( info );
-               }
-           }
+                // Change the state so that only template operations are valid
+                info.makeStateEstablished() ;
 
-           // Change the state so that no operations are valid,
-           // in case a reference to info escapes this scope.
-           // This also completes the actions associated with the
-           // template interceptors on this POA.
-           info.makeStateDone() ;
-       }
+                for( int i = (size - 1); i >= 0; i-- ) {
+                    IORInterceptor interceptor = iorInterceptors[i];
+                    if (interceptor instanceof IORInterceptor_3_0) {
+                        IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
+                        // Note that exceptions here are NOT ignored, as per the
+                        // ORT spec (orbos/01-01-04)
+                        interceptor30.components_established( info );
+                    }
+                }
+
+                // Change the state so that no operations are valid,
+                // in case a reference to info escapes this scope.
+                // This also completes the actions associated with the
+                // template interceptors on this POA.
+                info.makeStateDone() ;
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    void adapterManagerStateChanged( int managerId, short newState )
-    {
-       if (enabled) {
-           IORInterceptor[] interceptors = 
-                (IORInterceptor[])interceptorList.getInterceptors( 
-                InterceptorList.INTERCEPTOR_TYPE_IOR );
-           int size = interceptors.length;
+    void adapterManagerStateChanged( int managerId, short newState ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "adapterManagedStateChanged" ) ;
+        }
 
-           for( int i = (size - 1); i >= 0; i-- ) {
-               try {
-                   IORInterceptor interceptor = interceptors[i];
-                   if (interceptor instanceof IORInterceptor_3_0) {
-                       IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
-                       interceptor30.adapter_manager_state_changed( managerId, 
-                           newState );
-                   }
-               } catch (Exception exc) {
-                   // No-op: ignore exception in this case
-               }
-           }
-       }
+        try {
+            if (enabled) {
+                IORInterceptor[] interceptors = 
+                    (IORInterceptor[])interceptorList.getInterceptors( 
+                    InterceptorList.INTERCEPTOR_TYPE_IOR );
+                int size = interceptors.length;
+
+                for( int i = (size - 1); i >= 0; i-- ) {
+                    try {
+                        IORInterceptor interceptor = interceptors[i];
+                        if (interceptor instanceof IORInterceptor_3_0) {
+                            IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
+                            interceptor30.adapter_manager_state_changed( managerId, 
+                                newState );
+                        }
+                    } catch (Exception exc) {
+                        // No-op: ignore exception in this case
+                    }
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     void adapterStateChanged( ObjectReferenceTemplate[] templates,
-       short newState )
-    {
-       if (enabled) {
-           IORInterceptor[] interceptors = 
-                (IORInterceptor[])interceptorList.getInterceptors( 
-                InterceptorList.INTERCEPTOR_TYPE_IOR );
-           int size = interceptors.length;
+       short newState ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "adapterStateChanged" ) ;
+        }
 
-           for( int i = (size - 1); i >= 0; i-- ) {
-               try {
-                   IORInterceptor interceptor = interceptors[i];
-                   if (interceptor instanceof IORInterceptor_3_0) {
-                       IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
-                       interceptor30.adapter_state_changed( templates, newState );
-                   }
-               } catch (Exception exc) {
-                   // No-op: ignore exception in this case
-               }
-           }
-       }
+        try {
+            if (enabled) {
+                IORInterceptor[] interceptors = 
+                    (IORInterceptor[])interceptorList.getInterceptors( 
+                    InterceptorList.INTERCEPTOR_TYPE_IOR );
+                int size = interceptors.length;
+
+                for( int i = (size - 1); i >= 0; i-- ) {
+                    try {
+                        IORInterceptor interceptor = interceptors[i];
+                        if (interceptor instanceof IORInterceptor_3_0) {
+                            IORInterceptor_3_0 interceptor30 = (IORInterceptor_3_0)interceptor ;
+                            interceptor30.adapter_state_changed( templates, newState );
+                        }
+                    } catch (Exception exc) {
+                        // No-op: ignore exception in this case
+                    }
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /*
@@ -227,123 +244,123 @@
      * of info.getStartingPointCall()
      */
     void invokeClientInterceptorStartingPoint( ClientRequestInfoImpl info ) {
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled ) {
-           if (orb.interceptorDebugFlag) {
-               dprint( "->invokeClientInterceptorStartingPoint " + info ) ;
-           }
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeClientInterceptorStartingPoint",
+                "info", info ) ;
+        }
 
-           try {
-               // Make a a fresh slot table available to TSC in case
-               // interceptors need to make out calls.
-               // Client's TSC is now RSC via RequestInfo.
-               current.pushSlotTable( );
-               info.setPICurrentPushed( true );
-               info.setCurrentExecutionPoint( info.EXECUTION_POINT_STARTING );
-               
-               // Get all ClientRequestInterceptors:
-               ClientRequestInterceptor[] clientInterceptors = 
-                   (ClientRequestInterceptor[])interceptorList.
-                   getInterceptors( InterceptorList.INTERCEPTOR_TYPE_CLIENT );
-               int size = clientInterceptors.length;
+        try {
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled ) {
+                try {
+                    // Make a a fresh slot table available to TSC in case
+                    // interceptors need to make out calls.
+                    // Client's TSC is now RSC via RequestInfo.
+                    current.pushSlotTable( );
+                    info.setPICurrentPushed( true );
+                    info.setCurrentExecutionPoint( info.EXECUTION_POINT_STARTING );
+                    
+                    // Get all ClientRequestInterceptors:
+                    ClientRequestInterceptor[] clientInterceptors = 
+                        (ClientRequestInterceptor[])interceptorList.
+                        getInterceptors( InterceptorList.INTERCEPTOR_TYPE_CLIENT );
+                    int size = clientInterceptors.length;
 
-               // We will assume that all interceptors returned successfully,
-               // and adjust the flowStackIndex to the appropriate value if
-               // we later discover otherwise.
-               int flowStackIndex = size;
-               boolean continueProcessing = true;
-       
-               // Determine whether we are calling send_request or send_poll:
-               // (This is currently commented out because our ORB does not 
-               // yet support the Messaging specification, so send_poll will
-               // never occur.  Once we have implemented messaging, this may
-               // be uncommented.)
-               // int startingPointCall = info.getStartingPointCall();
-               for( int i = 0; continueProcessing && (i < size); i++ ) {
-                   ClientRequestInterceptor cri = clientInterceptors[i] ;
+                    // We will assume that all interceptors returned successfully,
+                    // and adjust the flowStackIndex to the appropriate value if
+                    // we later discover otherwise.
+                    int flowStackIndex = size;
+                    boolean continueProcessing = true;
+            
+                    // Determine whether we are calling send_request or send_poll:
+                    // (This is currently commented out because our ORB does not 
+                    // yet support the Messaging specification, so send_poll will
+                    // never occur.  Once we have implemented messaging, this may
+                    // be uncommented.)
+                    // int startingPointCall = info.getStartingPointCall();
+                    for( int i = 0; continueProcessing && (i < size); i++ ) {
+                        ClientRequestInterceptor cri = clientInterceptors[i] ;
 
-                   try {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorStartingPoint: " + 
-                               cri.name() + ".send_request" ) ;
-                       }
+                        try {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "calling send request on", cri.name() ) ;
+                            }
 
-                       cri.send_request( info );
-                       
-                       // Again, it is not necessary for a switch here, since
-                       // there is only one starting point call type (see
-                       // above comment).
-                       
-                       //switch( startingPointCall ) {
-                       //case ClientRequestInfoImpl.CALL_SEND_REQUEST:
-                           //clientInterceptors[i].send_request( info );
-                           //break;
-                       //case ClientRequestInfoImpl.CALL_SEND_POLL:
-                           //clientInterceptors[i].send_poll( info );
-                           //break;
-                       //}
+                            cri.send_request( info );
+                            
+                            // Again, it is not necessary for a switch here, since
+                            // there is only one starting point call type (see
+                            // above comment).
+                            
+                            //switch( startingPointCall ) {
+                            //case ClientRequestInfoImpl.CALL_SEND_REQUEST:
+                                //clientInterceptors[i].send_request( info );
+                                //break;
+                            //case ClientRequestInfoImpl.CALL_SEND_POLL:
+                                //clientInterceptors[i].send_poll( info );
+                                //break;
+                            //}
 
-                   } catch( ForwardRequest e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorStartingPoint " 
-                               + "ForwardRequest from " + cri.name() ) ;
-                       }
+                        } catch( ForwardRequest e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught forward request from", cri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
-                       // interception point throws a ForwardRequest, 
-                       // no other Interceptors' send_request operations are 
-                       // called.
-                       flowStackIndex = i;
-                       info.setForwardRequest( e );
-                       info.setEndingPointCall( 
-                           ClientRequestInfoImpl.CALL_RECEIVE_OTHER );
-                       info.setReplyStatus( LOCATION_FORWARD.value );
-                       
-                       updateClientRequestDispatcherForward( info );
-                       
-                       // For some reason, using break here causes the VM on 
-                       // NT to lose track of the value of flowStackIndex 
-                       // after exiting the for loop.  I changed this to 
-                       // check a boolean value instead and it seems to work 
-                       // fine.
-                       continueProcessing = false;
-                   } catch( SystemException e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorStartingPoint " 
-                               + "SystemException " + e + " from " 
-                               + cri.name() ) ;
-                       }
+                            // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
+                            // interception point throws a ForwardRequest, 
+                            // no other Interceptors' send_request operations are 
+                            // called.
+                            flowStackIndex = i;
+                            info.setForwardRequest( e );
+                            info.setEndingPointCall( 
+                                ClientRequestInfoImpl.CALL_RECEIVE_OTHER );
+                            info.setReplyStatus( LOCATION_FORWARD.value );
+                            
+                            updateClientRequestDispatcherForward( info );
+                            
+                            // For some reason, using break here causes the VM on 
+                            // NT to lose track of the value of flowStackIndex 
+                            // after exiting the for loop.  I changed this to 
+                            // check a boolean value instead and it seems to work 
+                            // fine.
+                            continueProcessing = false;
+                        } catch( SystemException e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught SystemException" + e + "from" 
+                                    + cri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
-                       // interception point throws a SystemException, 
-                       // no other Interceptors' send_request operations are 
-                       // called.
-                       flowStackIndex = i;
-                       info.setEndingPointCall( 
-                           ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION );
-                       info.setReplyStatus( SYSTEM_EXCEPTION.value );
-                       info.setException( e );
+                            // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
+                            // interception point throws a SystemException, 
+                            // no other Interceptors' send_request operations are 
+                            // called.
+                            flowStackIndex = i;
+                            info.setEndingPointCall( 
+                                ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION );
+                            info.setReplyStatus( SYSTEM_EXCEPTION.value );
+                            info.setException( e );
 
-                       // For some reason, using break here causes the VM on 
-                       // NT to lose track of the value of flowStackIndex 
-                       // after exiting the for loop.  I changed this to 
-                       // check a boolean value instead and it seems to 
-                       // work fine.
-                       continueProcessing = false;
-                   } 
-               }
-               
-               // Remember where we left off in the flow stack:
-               info.setFlowStackIndex( flowStackIndex );
-           } finally {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "<-invokeClientInterceptorStartingPoint " + info ) ;
-               }
-
-               // Make the SlotTable fresh for the next interception point.
-               current.resetSlotTable( );
-           }
-        } // end enabled check
+                            // For some reason, using break here causes the VM on 
+                            // NT to lose track of the value of flowStackIndex 
+                            // after exiting the for loop.  I changed this to 
+                            // check a boolean value instead and it seems to 
+                            // work fine.
+                            continueProcessing = false;
+                        } 
+                    }
+                    
+                    // Remember where we left off in the flow stack:
+                    info.setFlowStackIndex( flowStackIndex );
+                } finally {
+                    // Make the SlotTable fresh for the next interception point.
+                    current.resetSlotTable( );
+                }
+            } // end enabled check
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     private String getClientEndMethodName( int endingPointCall ) {
@@ -363,110 +380,110 @@
      * depending on the value of info.getEndingPointCall()
      */
     void invokeClientInterceptorEndingPoint( ClientRequestInfoImpl info ) {
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled ) {
-           try {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "->invokeClientInterceptorEndingPoint " + info ) ;
-               }
-               
-               // NOTE: It is assumed someplace else prepared a
-               // fresh TSC slot table.
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeClientInterceptorEndingPoint" ) ;
+        }
 
-               info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
-               
-               // Get all ClientRequestInterceptors:
-               ClientRequestInterceptor[] clientInterceptors = 
-                   (ClientRequestInterceptor[])interceptorList.
-                   getInterceptors( InterceptorList.INTERCEPTOR_TYPE_CLIENT );
-               int flowStackIndex = info.getFlowStackIndex();
-               
-               // Determine whether we are calling receive_reply, 
-               // receive_exception, or receive_other:
-               int endingPointCall = info.getEndingPointCall();
+        try {
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled ) {
+                try {
+                    // NOTE: It is assumed someplace else prepared a
+                    // fresh TSC slot table.
 
-               // If we would be calling RECEIVE_REPLY, but this is a 
-               // one-way call, override this and call receive_other:
-               if( ( endingPointCall == 
-                     ClientRequestInfoImpl.CALL_RECEIVE_REPLY ) &&
-                   info.getIsOneWay() )
-               {
-                   endingPointCall = ClientRequestInfoImpl.CALL_RECEIVE_OTHER;
-                   info.setEndingPointCall( endingPointCall );
-               }
-               
-               // Only step through the interceptors whose starting points
-               // have successfully returned.
-               // Unlike the previous loop, this one counts backwards for a 
-               // reason - we must execute these in the reverse order of the
-               // starting points.
-               for( int i = (flowStackIndex - 1); i >= 0; i-- ) {
-                   ClientRequestInterceptor cri = clientInterceptors[i] ;
+                    info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
+                    
+                    // Get all ClientRequestInterceptors:
+                    ClientRequestInterceptor[] clientInterceptors = 
+                        (ClientRequestInterceptor[])interceptorList.
+                        getInterceptors( InterceptorList.INTERCEPTOR_TYPE_CLIENT );
+                    int flowStackIndex = info.getFlowStackIndex();
+                    
+                    // Determine whether we are calling receive_reply, 
+                    // receive_exception, or receive_other:
+                    int endingPointCall = info.getEndingPointCall();
 
-                   try {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorEndingPoint: " 
-                               + "Interceptor " + cri.name() + "." 
-                               + getClientEndMethodName( endingPointCall ) ) ;
-                       }
-                   
-                       switch( endingPointCall ) {
-                       case ClientRequestInfoImpl.CALL_RECEIVE_REPLY:
-                           cri.receive_reply( info );
-                           break;
-                       case ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION:
-                           cri.receive_exception( info );
-                           break;
-                       case ClientRequestInfoImpl.CALL_RECEIVE_OTHER:
-                           cri.receive_other( info );
-                           break;
-                       }
-                   } catch( ForwardRequest e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorEndingPoint " 
-                               + "ForwardRequest from " + cri.name() ) ;
-                       }
+                    // If we would be calling RECEIVE_REPLY, but this is a 
+                    // one-way call, override this and call receive_other:
+                    if( ( endingPointCall == 
+                          ClientRequestInfoImpl.CALL_RECEIVE_REPLY ) &&
+                        info.getIsOneWay() )
+                    {
+                        endingPointCall = ClientRequestInfoImpl.CALL_RECEIVE_OTHER;
+                        info.setEndingPointCall( endingPointCall );
+                    }
+                    
+                    // Only step through the interceptors whose starting points
+                    // have successfully returned.
+                    // Unlike the previous loop, this one counts backwards for a 
+                    // reason - we must execute these in the reverse order of the
+                    // starting points.
+                    for( int i = (flowStackIndex - 1); i >= 0; i-- ) {
+                        ClientRequestInterceptor cri = clientInterceptors[i] ;
 
-                       // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
-                       // interception point throws a ForwardException, 
-                       // ending point call changes to receive_other.
-                       endingPointCall = 
-                           ClientRequestInfoImpl.CALL_RECEIVE_OTHER;
-                       info.setEndingPointCall( endingPointCall );
-                       info.setReplyStatus( LOCATION_FORWARD.value );
-                       info.setForwardRequest( e );
-                       updateClientRequestDispatcherForward( info );
-                   } catch( SystemException e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeClientInterceptorEndingPoint " 
-                               + "SystemException " + e + " from " 
-                               + cri.name() ) ;
-                       }
+                        try {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "Interceptor" + cri.name() + "method" 
+                                    + getClientEndMethodName( endingPointCall ) ) ;
+                            }
+                        
+                            switch( endingPointCall ) {
+                            case ClientRequestInfoImpl.CALL_RECEIVE_REPLY:
+                                cri.receive_reply( info );
+                                break;
+                            case ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION:
+                                cri.receive_exception( info );
+                                break;
+                            case ClientRequestInfoImpl.CALL_RECEIVE_OTHER:
+                                cri.receive_other( info );
+                                break;
+                            }
+                        } catch( ForwardRequest e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught ForwardRequest from " 
+                                    + cri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
-                       // interception point throws a SystemException, 
-                       // ending point call changes to receive_exception.
-                       endingPointCall = 
-                           ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION;
-                       info.setEndingPointCall( endingPointCall );
-                       info.setReplyStatus( SYSTEM_EXCEPTION.value );
-                       info.setException( e );
-                   } 
-               }
-           } finally {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "<-invokeClientInterceptorEndingPoint " + info ) ;
-               }
+                            // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
+                            // interception point throws a ForwardException, 
+                            // ending point call changes to receive_other.
+                            endingPointCall = 
+                                ClientRequestInfoImpl.CALL_RECEIVE_OTHER;
+                            info.setEndingPointCall( endingPointCall );
+                            info.setReplyStatus( LOCATION_FORWARD.value );
+                            info.setForwardRequest( e );
+                            updateClientRequestDispatcherForward( info );
+                        } catch( SystemException e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught SystemException" + e 
+                                    + "from" + cri.name() ) ;
+                            }
 
-               // See doc for setPICurrentPushed as to why this is necessary.
-               // Check info for null in case errors happen before initiate.
-               if (info != null && info.isPICurrentPushed()) {
-                   current.popSlotTable( );
-                   // After the pop, original client's TSC slot table
-                   // remains avaiable via PICurrent.
-               }
-           }
-        } // end enabled check
+                            // as per PI spec (orbos/99-12-02 sec 5.2.1.), if
+                            // interception point throws a SystemException, 
+                            // ending point call changes to receive_exception.
+                            endingPointCall = 
+                                ClientRequestInfoImpl.CALL_RECEIVE_EXCEPTION;
+                            info.setEndingPointCall( endingPointCall );
+                            info.setReplyStatus( SYSTEM_EXCEPTION.value );
+                            info.setException( e );
+                        } 
+                    }
+                } finally {
+                    // See doc for setPICurrentPushed as to why this is necessary.
+                    // Check info for null in case errors happen before initiate.
+                    if (info != null && info.isPICurrentPushed()) {
+                        current.popSlotTable( );
+                        // After the pop, original client's TSC slot table
+                        // remains avaiable via PICurrent.
+                    }
+                }
+            } // end enabled check
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /*
@@ -478,113 +495,113 @@
      * Invokes receive_request_service_context interception points.
      */
     void invokeServerInterceptorStartingPoint( ServerRequestInfoImpl info ) {
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled ) {
-           try {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "->invokeServerInterceptorStartingPoint " + info ) ;
-               }
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokerServerInterceptorStartingPoint",
+                "info", info ) ;
+        }
 
-               // Make a fresh slot table for RSC.
-               current.pushSlotTable();
-               info.setSlotTable(current.getSlotTable());
+        try {
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled ) {
+                try {
+                    // Make a fresh slot table for RSC.
+                    current.pushSlotTable();
+                    info.setSlotTable(current.getSlotTable());
 
-               // Make a fresh slot table for TSC in case
-               // interceptors need to make out calls.
-               current.pushSlotTable( );
+                    // Make a fresh slot table for TSC in case
+                    // interceptors need to make out calls.
+                    current.pushSlotTable( );
 
-               info.setCurrentExecutionPoint( info.EXECUTION_POINT_STARTING );
-               
-               // Get all ServerRequestInterceptors:
-               ServerRequestInterceptor[] serverInterceptors = 
-                   (ServerRequestInterceptor[])interceptorList.
-                   getInterceptors( InterceptorList.INTERCEPTOR_TYPE_SERVER );
-               int size = serverInterceptors.length;
+                    info.setCurrentExecutionPoint( info.EXECUTION_POINT_STARTING );
+                    
+                    // Get all ServerRequestInterceptors:
+                    ServerRequestInterceptor[] serverInterceptors = 
+                        (ServerRequestInterceptor[])interceptorList.
+                        getInterceptors( InterceptorList.INTERCEPTOR_TYPE_SERVER );
+                    int size = serverInterceptors.length;
 
-               // We will assume that all interceptors returned successfully,
-               // and adjust the flowStackIndex to the appropriate value if
-               // we later discover otherwise.
-               int flowStackIndex = size;
-               boolean continueProcessing = true;
-               
-               // Currently, there is only one server-side starting point
-               // interceptor called receive_request_service_contexts.
-               for( int i = 0; continueProcessing && (i < size); i++ ) {
-                   ServerRequestInterceptor sri = serverInterceptors[i] ; 
-                   try {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorStartingPoint: " 
-                               + "Interceptor " + sri.name() 
-                               + ".receive_request_service_contexts" ) ;
-                       }
-                   
-                       sri.receive_request_service_contexts( info );
-                   } catch( ForwardRequest e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorStartingPoint " 
-                               + "ForwardException from " 
-                               + sri.name() ) ;
-                       }
+                    // We will assume that all interceptors returned successfully,
+                    // and adjust the flowStackIndex to the appropriate value if
+                    // we later discover otherwise.
+                    int flowStackIndex = size;
+                    boolean continueProcessing = true;
+                    
+                    // Currently, there is only one server-side starting point
+                    // interceptor called receive_request_service_contexts.
+                    for( int i = 0; continueProcessing && (i < size); i++ ) {
+                        ServerRequestInterceptor sri = serverInterceptors[i] ; 
+                        try {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "Interceptor " + sri.name() 
+                                    + "receive_request_service_contexts" ) ;
+                            }
+                        
+                            sri.receive_request_service_contexts( info );
+                        } catch( ForwardRequest e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught ForwardException from " 
+                                    + sri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                       // interception point throws a ForwardRequest, 
-                       // no other Interceptors' starting points are 
-                       // called and send_other is called.
-                       flowStackIndex = i;
-                       info.setForwardRequest( e );
-                       info.setIntermediatePointCall(
-                           ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE );
-                       info.setEndingPointCall( 
-                           ServerRequestInfoImpl.CALL_SEND_OTHER );
-                       info.setReplyStatus( LOCATION_FORWARD.value );
+                            // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                            // interception point throws a ForwardRequest, 
+                            // no other Interceptors' starting points are 
+                            // called and send_other is called.
+                            flowStackIndex = i;
+                            info.setForwardRequest( e );
+                            info.setIntermediatePointCall(
+                                ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE );
+                            info.setEndingPointCall( 
+                                ServerRequestInfoImpl.CALL_SEND_OTHER );
+                            info.setReplyStatus( LOCATION_FORWARD.value );
 
-                       // For some reason, using break here causes the VM on 
-                       // NT to lose track of the value of flowStackIndex 
-                       // after exiting the for loop.  I changed this to 
-                       // check a boolean value instead and it seems to work 
-                       // fine.
-                       continueProcessing = false;
-                   } catch( SystemException e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorStartingPoint " 
-                               + "SystemException " + e + " from " 
-                               + sri.name() ) ;
-                       }
+                            // For some reason, using break here causes the VM on 
+                            // NT to lose track of the value of flowStackIndex 
+                            // after exiting the for loop.  I changed this to 
+                            // check a boolean value instead and it seems to work 
+                            // fine.
+                            continueProcessing = false;
+                        } catch( SystemException e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught SystemException " + e 
+                                    + "from" + sri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                       // interception point throws a SystemException, 
-                       // no other Interceptors' starting points are 
-                       // called.
-                       flowStackIndex = i;
-                       info.setException( e );
-                       info.setIntermediatePointCall(
-                           ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE );
-                       info.setEndingPointCall( 
-                           ServerRequestInfoImpl.CALL_SEND_EXCEPTION );
-                       info.setReplyStatus( SYSTEM_EXCEPTION.value );
+                            // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                            // interception point throws a SystemException, 
+                            // no other Interceptors' starting points are 
+                            // called.
+                            flowStackIndex = i;
+                            info.setException( e );
+                            info.setIntermediatePointCall(
+                                ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE );
+                            info.setEndingPointCall( 
+                                ServerRequestInfoImpl.CALL_SEND_EXCEPTION );
+                            info.setReplyStatus( SYSTEM_EXCEPTION.value );
 
-                       // For some reason, using break here causes the VM on 
-                       // NT to lose track of the value of flowStackIndex 
-                       // after exiting the for loop.  I changed this to 
-                       // check a boolean value instead and it seems to 
-                       // work fine.
-                       continueProcessing = false;
-                   }
-           
-               }
-               
-               // Remember where we left off in the flow stack:
-               info.setFlowStackIndex( flowStackIndex );
-           } finally {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "<-invokeServerInterceptorStartingPoint " + info ) ;
-               }
-               // The remaining points, ServantManager and Servant
-               // all run in the same logical thread.
-               current.popSlotTable( );
-               // Now TSC and RSC are equivalent.
-           }
-        } // end enabled check
+                            // For some reason, using break here causes the VM on 
+                            // NT to lose track of the value of flowStackIndex 
+                            // after exiting the for loop.  I changed this to 
+                            // check a boolean value instead and it seems to 
+                            // work fine.
+                            continueProcessing = false;
+                        }
+                    }
+                    
+                    // Remember where we left off in the flow stack:
+                    info.setFlowStackIndex( flowStackIndex );
+                } finally {
+                    // The remaining points, ServantManager and Servant
+                    // all run in the same logical thread.
+                    current.popSlotTable( );
+                    // Now TSC and RSC are equivalent.
+                }
+            } // end enabled check
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
@@ -593,77 +610,78 @@
     void invokeServerInterceptorIntermediatePoint( 
         ServerRequestInfoImpl info ) 
     {
-        int intermediatePointCall = info.getIntermediatePointCall();
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled && ( intermediatePointCall != 
-                         ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE ) ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeServerInterceptorIntermediatePoint",
+                "info", info ) ;
+        }
 
-           if (orb.interceptorDebugFlag) {
-               dprint( "->invokeServerInterceptorIntermediatePoint " + info ) ;
-           }
-           // NOTE: do not touch the slotStack.  The RSC and TSC are
-           // equivalent at this point.
+        try {
+            int intermediatePointCall = info.getIntermediatePointCall();
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled && ( intermediatePointCall != 
+                             ServerRequestInfoImpl.CALL_INTERMEDIATE_NONE ) ) {
 
-            info.setCurrentExecutionPoint( info.EXECUTION_POINT_INTERMEDIATE );
-            
-            // Get all ServerRequestInterceptors:
-            ServerRequestInterceptor[] serverInterceptors = 
-                (ServerRequestInterceptor[])
-                interceptorList.getInterceptors( 
-                InterceptorList.INTERCEPTOR_TYPE_SERVER );
-            int size = serverInterceptors.length;
+                // NOTE: do not touch the slotStack.  The RSC and TSC are
+                // equivalent at this point.
 
-            // Currently, there is only one server-side intermediate point
-            // interceptor called receive_request.
-            for( int i = 0; i < size; i++ ) {
-               ServerRequestInterceptor sri = serverInterceptors[i] ;
-                try {
-                   if (orb.interceptorDebugFlag) {
-                       dprint( ".invokeServerInterceptorIntermediatePoint: " 
-                           + "Interceptor " + sri.name() 
-                           + ".receive_request" ) ;
-                   }
-                   
-                    sri.receive_request( info );
-                } catch( ForwardRequest e ) {
-                   if (orb.interceptorDebugFlag) {
-                       dprint( ".invokeServerInterceptorIntermediatePoint " 
-                           + "ForwardException from " 
-                           + sri.name() ) ;
-                   }
+                info.setCurrentExecutionPoint( info.EXECUTION_POINT_INTERMEDIATE );
+                
+                // Get all ServerRequestInterceptors:
+                ServerRequestInterceptor[] serverInterceptors = 
+                    (ServerRequestInterceptor[])
+                    interceptorList.getInterceptors( 
+                    InterceptorList.INTERCEPTOR_TYPE_SERVER );
+                int size = serverInterceptors.length;
 
-                    // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                    // interception point throws a ForwardRequest, 
-                    // no other Interceptors' intermediate points are 
-                    // called and send_other is called.
-                   info.setForwardRequest( e );
-                    info.setEndingPointCall( 
-                        ServerRequestInfoImpl.CALL_SEND_OTHER );
-                    info.setReplyStatus( LOCATION_FORWARD.value );
-                    break;
-                } catch( SystemException e ) {
-                   if (orb.interceptorDebugFlag) {
-                       dprint( ".invokeServerInterceptorIntermediatePoint " 
-                           + "SystemException " + e + " from " 
-                           + sri.name() ) ;
-                   }
+                // Currently, there is only one server-side intermediate point
+                // interceptor called receive_request.
+                for( int i = 0; i < size; i++ ) {
+                    ServerRequestInterceptor sri = serverInterceptors[i] ;
+                    try {
+                        if (orb.interceptorDebugFlag) {
+                            dputil.info( "Interceptor " + sri.name() 
+                                + "receive_request" ) ;
+                        }
+                        
+                        sri.receive_request( info );
+                    } catch( ForwardRequest e ) {
+                        if (orb.interceptorDebugFlag) {
+                            dputil.info( "caught ForwardException from " 
+                                + sri.name() ) ;
+                        }
 
-                    // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                    // interception point throws a SystemException, 
-                    // no other Interceptors' starting points are 
-                    // called.
-                   info.setException( e );
-                    info.setEndingPointCall( 
-                        ServerRequestInfoImpl.CALL_SEND_EXCEPTION );
-                    info.setReplyStatus( SYSTEM_EXCEPTION.value );
-                    break;
+                        // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                        // interception point throws a ForwardRequest, 
+                        // no other Interceptors' intermediate points are 
+                        // called and send_other is called.
+                        info.setForwardRequest( e );
+                        info.setEndingPointCall( 
+                            ServerRequestInfoImpl.CALL_SEND_OTHER );
+                        info.setReplyStatus( LOCATION_FORWARD.value );
+                        break;
+                    } catch( SystemException e ) {
+                        if (orb.interceptorDebugFlag) {
+                            dputil.info( "caught SystemException " + e 
+                                + "from" + sri.name() ) ;
+                        }
+
+                        // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                        // interception point throws a SystemException, 
+                        // no other Interceptors' starting points are 
+                        // called.
+                        info.setException( e );
+                        info.setEndingPointCall( 
+                            ServerRequestInfoImpl.CALL_SEND_EXCEPTION );
+                        info.setReplyStatus( SYSTEM_EXCEPTION.value );
+                        break;
+                    }
                 }
+            } // end enabled check
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
             }
-
-           if (orb.interceptorDebugFlag) {
-               dprint( "<-invokeServerInterceptorIntermediatePoint " + info ) ;
-           }
-        } // end enabled check
+        }
     }
 
     private String getServerEndMethodName( int endingPointCall ) {
@@ -683,102 +701,102 @@
      * depending on the value of info.getEndingPointCall()
      */
     void invokeServerInterceptorEndingPoint( ServerRequestInfoImpl info ) {
-       // If invocation is not yet enabled, don't do anything.
-       if( enabled ) {
-           try {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "->invokeServerInterceptorEndingPoint " + info ) ;
-               }
-               
-               // NOTE: do not touch the slotStack.  The RSC and TSC are
-               // equivalent at this point.
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeServerInterceptorEndingPoint", "info", info ) ;
+        }
 
-               // REVISIT: This is moved out to PIHandlerImpl until dispatch
-               // path is rearchitected.  It must be there so that
-               // it always gets executed so if an interceptor raises
-               // an exception any service contexts added in earlier points
-               // this point get put in the exception reply (via the SC Q).
-               //info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
-               
-               // Get all ServerRequestInterceptors:
-               ServerRequestInterceptor[] serverInterceptors = 
-                   (ServerRequestInterceptor[])interceptorList.
-                   getInterceptors( InterceptorList.INTERCEPTOR_TYPE_SERVER );
-               int flowStackIndex = info.getFlowStackIndex();
-               
-               // Determine whether we are calling 
-               // send_exception, or send_other:
-               int endingPointCall = info.getEndingPointCall();
-               
-               // Only step through the interceptors whose starting points
-               // have successfully returned.
-               for( int i = (flowStackIndex - 1); i >= 0; i-- ) {
-                   ServerRequestInterceptor sri = serverInterceptors[i] ;
+        try {
+            // If invocation is not yet enabled, don't do anything.
+            if( enabled ) {
+                try {
+                    // NOTE: do not touch the slotStack.  The RSC and TSC are
+                    // equivalent at this point.
 
-                   try {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorEndingPoint: " 
-                               + "Interceptor " + sri.name() + "." 
-                               + getServerEndMethodName( endingPointCall ) ) ;
-                       }
-                   
-                       
-                       switch( endingPointCall ) {
-                       case ServerRequestInfoImpl.CALL_SEND_REPLY:
-                           sri.send_reply( info );
-                           break;
-                       case ServerRequestInfoImpl.CALL_SEND_EXCEPTION:
-                           sri.send_exception( info );
-                           break;
-                       case ServerRequestInfoImpl.CALL_SEND_OTHER:
-                           sri.send_other( info );
-                           break;
-                       }
-                   } catch( ForwardRequest e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorEndingPoint " 
-                               + "ForwardRequest from " + sri.name() ) ;
-                       }
+                    // REVISIT: This is moved out to PIHandlerImpl until dispatch
+                    // path is rearchitected.  It must be there so that
+                    // it always gets executed so if an interceptor raises
+                    // an exception any service contexts added in earlier points
+                    // this point get put in the exception reply (via the SC Q).
+                    //info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
+                    
+                    // Get all ServerRequestInterceptors:
+                    ServerRequestInterceptor[] serverInterceptors = 
+                        (ServerRequestInterceptor[])interceptorList.
+                        getInterceptors( InterceptorList.INTERCEPTOR_TYPE_SERVER );
+                    int flowStackIndex = info.getFlowStackIndex();
+                    
+                    // Determine whether we are calling 
+                    // send_exception, or send_other:
+                    int endingPointCall = info.getEndingPointCall();
+                    
+                    // Only step through the interceptors whose starting points
+                    // have successfully returned.
+                    for( int i = (flowStackIndex - 1); i >= 0; i-- ) {
+                        ServerRequestInterceptor sri = serverInterceptors[i] ;
 
-                       // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                       // interception point throws a ForwardException, 
-                       // ending point call changes to receive_other.
-                       endingPointCall = 
-                           ServerRequestInfoImpl.CALL_SEND_OTHER;
-                       info.setEndingPointCall( endingPointCall );
-                       info.setForwardRequest( e );
-                       info.setReplyStatus( LOCATION_FORWARD.value );
-                       info.setForwardRequestRaisedInEnding();
-                   } catch( SystemException e ) {
-                       if (orb.interceptorDebugFlag) {
-                           dprint( ".invokeServerInterceptorEndingPoint " 
-                               + "SystemException " + e + " from " 
-                               + sri.name() ) ;
-                       }
+                        try {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "Interceptor " + sri.name() 
+                                    + "method" + getServerEndMethodName( endingPointCall ) ) ;
+                            }
+                        
+                            
+                            switch( endingPointCall ) {
+                            case ServerRequestInfoImpl.CALL_SEND_REPLY:
+                                sri.send_reply( info );
+                                break;
+                            case ServerRequestInfoImpl.CALL_SEND_EXCEPTION:
+                                sri.send_exception( info );
+                                break;
+                            case ServerRequestInfoImpl.CALL_SEND_OTHER:
+                                sri.send_other( info );
+                                break;
+                            }
+                        } catch( ForwardRequest e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught ForwardRequest from " 
+                                    + sri.name() ) ;
+                            }
 
-                       // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
-                       // interception point throws a SystemException, 
-                       // ending point call changes to send_exception.
-                       endingPointCall = 
-                           ServerRequestInfoImpl.CALL_SEND_EXCEPTION;
-                       info.setEndingPointCall( endingPointCall );
-                       info.setException( e );
-                       info.setReplyStatus( SYSTEM_EXCEPTION.value );
-                   }
-               }
-               
-               // Remember that all interceptors' starting and ending points
-               // have already been executed so we need not do anything.
-               info.setAlreadyExecuted( true );
-           } finally {
-               if (orb.interceptorDebugFlag) {
-                   dprint( "<-invokeServerInterceptorEndingPoint " + info ) ;
-               }
-               
-               // Get rid of the Server side RSC.
-               current.popSlotTable();
-           }
-        } // end enabled check
+                            // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                            // interception point throws a ForwardException, 
+                            // ending point call changes to receive_other.
+                            endingPointCall = 
+                                ServerRequestInfoImpl.CALL_SEND_OTHER;
+                            info.setEndingPointCall( endingPointCall );
+                            info.setForwardRequest( e );
+                            info.setReplyStatus( LOCATION_FORWARD.value );
+                            info.setForwardRequestRaisedInEnding();
+                        } catch( SystemException e ) {
+                            if (orb.interceptorDebugFlag) {
+                                dputil.info( "caught SystemException " + e 
+                                    + "from" + sri.name() ) ;
+                            }
+
+                            // as per PI spec (orbos/99-12-02 sec 5.3.1.), if
+                            // interception point throws a SystemException, 
+                            // ending point call changes to send_exception.
+                            endingPointCall = 
+                                ServerRequestInfoImpl.CALL_SEND_EXCEPTION;
+                            info.setEndingPointCall( endingPointCall );
+                            info.setException( e );
+                            info.setReplyStatus( SYSTEM_EXCEPTION.value );
+                        }
+                    }
+                    
+                    // Remember that all interceptors' starting and ending points
+                    // have already been executed so we need not do anything.
+                    info.setAlreadyExecuted( true );
+                } finally {
+                    // Get rid of the Server side RSC.
+                    current.popSlotTable();
+                }
+            } // end enabled check
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /*
@@ -793,18 +811,28 @@
     private void updateClientRequestDispatcherForward( 
         ClientRequestInfoImpl info ) 
     {
-        ForwardRequest forwardRequest = info.getForwardRequestException();
-        
-        // ForwardRequest may be null if the forwarded IOR is set internal
-        // to the ClientRequestDispatcher rather than explicitly through Portable
-        // Interceptors.  In this case, we need not update the client 
-        // delegate ForwardRequest object.
-        if( forwardRequest != null ) {
-            org.omg.CORBA.Object object = forwardRequest.forward;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "updateClientRequestDispatcherForward" ) ;
+        }
 
-            // Convert the forward object into an IOR:
-           IOR ior = orb.getIOR( object, false ) ;
-           info.setLocatedIOR( ior );
+        try {
+            ForwardRequest forwardRequest = info.getForwardRequestException();
+            
+            // ForwardRequest may be null if the forwarded IOR is set internal
+            // to the ClientRequestDispatcher rather than explicitly through Portable
+            // Interceptors.  In this case, we need not update the client 
+            // delegate ForwardRequest object.
+            if( forwardRequest != null ) {
+                org.omg.CORBA.Object object = forwardRequest.forward;
+
+                // Convert the forward object into an IOR:
+                IOR ior = orb.getIOR( object, false ) ;
+                info.setLocatedIOR( ior );
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
     
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/interceptors/PIHandlerImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/interceptors/PIHandlerImpl.java   Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/interceptors/PIHandlerImpl.java   Mon Jul 06 12:05:55 2009 -0700
@@ -36,33 +36,24 @@
 package com.sun.corba.ee.impl.interceptors;
 
 import java.util.*;
-import java.io.IOException;
              
 import org.omg.CORBA.Any;
 import org.omg.CORBA.BAD_PARAM;
 import org.omg.CORBA.BAD_POLICY;
-import org.omg.CORBA.BAD_INV_ORDER;
-import org.omg.CORBA.COMM_FAILURE;
 import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.INTERNAL;
 import org.omg.CORBA.NVList;
-import org.omg.CORBA.OBJECT_NOT_EXIST;
-import org.omg.CORBA.ORBPackage.InvalidName;
 import org.omg.CORBA.SystemException;
 import org.omg.CORBA.UserException;
-import org.omg.CORBA.UNKNOWN;
 
 import org.omg.CORBA.portable.ApplicationException;
 import org.omg.CORBA.portable.RemarshalException;
 
 import org.omg.IOP.CodecFactory;
 
-import org.omg.PortableInterceptor.ForwardRequest;
 import org.omg.PortableInterceptor.Current;
 import org.omg.PortableInterceptor.Interceptor;
 import org.omg.PortableInterceptor.LOCATION_FORWARD;
 import org.omg.PortableInterceptor.ORBInitializer;
-import org.omg.PortableInterceptor.ORBInitInfo;
 import org.omg.PortableInterceptor.ORBInitInfoPackage.DuplicateName;
 import org.omg.PortableInterceptor.SUCCESSFUL;
 import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;
@@ -71,7 +62,6 @@
 import org.omg.PortableInterceptor.PolicyFactory;
 import org.omg.PortableInterceptor.ObjectReferenceTemplate ;
 
-import com.sun.corba.ee.pept.encoding.OutputObject;
 
 import com.sun.corba.ee.spi.ior.IOR;
 import com.sun.corba.ee.spi.ior.ObjectKeyTemplate;
@@ -81,14 +71,16 @@
 import com.sun.corba.ee.spi.protocol.CorbaMessageMediator;
 import com.sun.corba.ee.spi.protocol.ForwardException;
 import com.sun.corba.ee.spi.protocol.PIHandler;
-import com.sun.corba.ee.spi.orbutil.misc.StackImpl;
+import com.sun.corba.ee.spi.protocol.RetryType ;
 
 import com.sun.corba.ee.impl.logging.InterceptorsSystemException;
 import com.sun.corba.ee.impl.logging.ORBUtilSystemException;
 import com.sun.corba.ee.impl.logging.OMGSystemException;
 import com.sun.corba.ee.impl.corba.RequestImpl;
+
 import com.sun.corba.ee.spi.orbutil.ORBConstants;
-import com.sun.corba.ee.impl.orbutil.ORBUtility;
+
+import com.sun.corba.ee.impl.orbutil.DprintUtil;
 import com.sun.corba.ee.impl.protocol.giopmsgheaders.ReplyMessage;
 
 /** 
@@ -96,31 +88,9 @@
  */
 public class PIHandlerImpl implements PIHandler 
 {
-    // REVISIT - delete these after framework merging.
-    boolean printPushPopEnabled = false;
-    int pushLevel = 0;
-    private void printPush()
-    {
-       if (! printPushPopEnabled) return;
-       printSpaces(pushLevel);
-       pushLevel++;
-       System.out.println("PUSH");
-    }
-    private void printPop()
-    {
-       if (! printPushPopEnabled) return;
-       pushLevel--;
-       printSpaces(pushLevel);
-       System.out.println("POP");
-    }
-    private void printSpaces(int n)
-    {
-       for (int i = 0; i < n; i++) {
-           System.out.print(" ");
-       }
-    }
+    private ORB orb ;
+    private DprintUtil dputil = new DprintUtil( this ) ;
 
-    private ORB orb ;
     InterceptorsSystemException wrapper ;
     ORBUtilSystemException orbutilWrapper ;
     OMGSystemException omgWrapper ;
@@ -168,12 +138,24 @@
         LOCATION_FORWARD.value, // = ReplyMessage.LOCATION_FORWARD_PERM
         TRANSPORT_RETRY.value   // = ReplyMessage.NEEDS_ADDRESSING_MODE
     };
-            
+        
+    static String getReplyStatus( int piReplyStatus ) {
+        switch (piReplyStatus) {
+            case SUCCESSFUL.value: return "SUCCESSFUL" ;
+            case USER_EXCEPTION.value: return "USER_EXCEPTION" ;
+            case SYSTEM_EXCEPTION.value: return "SYSTEM_EXCEPTION" ;
+            case LOCATION_FORWARD.value: return "LOCATION_FORWARD" ;
+            case TRANSPORT_RETRY.value: return "TRANSPORT_RETRY" ;
+            default: return "UNINITIALIZED" ;
+        }
+    }
+
     // ThreadLocal containing a stack to store client request info objects
     // and a disable count.
     private ThreadLocal<RequestInfoStack<ClientRequestInfoImpl>> 
        threadLocalClientRequestInfoStack = 
            new ThreadLocal<RequestInfoStack<ClientRequestInfoImpl>>() {
+                @Override
                protected RequestInfoStack<ClientRequestInfoImpl> initialValue() {
                    return new RequestInfoStack<ClientRequestInfoImpl>();
                }
@@ -183,24 +165,37 @@
     private ThreadLocal<RequestInfoStack<ServerRequestInfoImpl>>
        threadLocalServerRequestInfoStack =
        new ThreadLocal<RequestInfoStack<ServerRequestInfoImpl>>() {
+            @Override
            protected RequestInfoStack<ServerRequestInfoImpl> initialValue() {
                return new RequestInfoStack<ServerRequestInfoImpl>();
            }
        };
     
     public void close() {
-        orb = null ;
-        wrapper = null ;
-        orbutilWrapper = null ;
-        omgWrapper = null ;
-        codecFactory = null ;
-        arguments = null ;
-        interceptorList = null ;
-        interceptorInvoker = null ;
-        current = null ;
-        policyFactoryTable = null ;
-        threadLocalClientRequestInfoStack = null ;
-        threadLocalServerRequestInfoStack = null ;
+        // be careful: close nulls the orb reference
+        boolean debug = orb.interceptorDebugFlag ;
+        if (debug) {
+            dputil.enter( "close" ) ;
+        }
+
+        try {
+            orb = null ;
+            wrapper = null ;
+            orbutilWrapper = null ;
+            omgWrapper = null ;
+            codecFactory = null ;
+            arguments = null ;
+            interceptorList = null ;
+            interceptorInvoker = null ;
+            current = null ;
+            policyFactoryTable = null ;
+            threadLocalClientRequestInfoStack = null ;
+            threadLocalServerRequestInfoStack = null ;
+        } finally {
+            if (debug) {
+                dputil.exit() ;
+            }
+        }
     }
     // Class to contain all ThreadLocal data for ClientRequestInfo
     // maintenance.
@@ -215,78 +210,98 @@
     }
         
     public PIHandlerImpl( ORB orb, String[] args ) {
-       this.orb = orb ;
-       wrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_Interceptors() ;
-       orbutilWrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_ORBUtil() ;
-       omgWrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_OMG() ;
-       arguments = args ;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "<init>(ORB,String[])" ) ;
+        }
 
-       // Create codec factory:
-       codecFactory = new CodecFactoryImpl( orb );
+        try {
+            this.orb = orb ;
+            wrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_Interceptors() ;
+            orbutilWrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_ORBUtil() ;
+            omgWrapper = orb.getLogWrapperTable().get_RPC_PROTOCOL_OMG() ;
+            arguments = args ;
 
-       // Create new interceptor list:
-       interceptorList = new InterceptorList( wrapper );
+            // Create codec factory:
+            codecFactory = new CodecFactoryImpl( orb );
 
-        // Create a new PICurrent.
-        current = new PICurrent( orb );
+            // Create new interceptor list:
+            interceptorList = new InterceptorList( wrapper );
 
-       // Create new interceptor invoker, initially disabled:
-       interceptorInvoker = new InterceptorInvoker( orb, interceptorList, 
-                                                     current );
+            // Create a new PICurrent.
+            current = new PICurrent( orb );
 
-       // Register the PI current and Codec factory objects
-       orb.getLocalResolver().register( ORBConstants.PI_CURRENT_NAME, 
-           ClosureFactory.makeConstant( current ) ) ;
-       orb.getLocalResolver().register( ORBConstants.CODEC_FACTORY_NAME, 
-           ClosureFactory.makeConstant( codecFactory ) ) ;
+            // Create new interceptor invoker, initially disabled:
+            interceptorInvoker = new InterceptorInvoker( orb, interceptorList, 
+                                                         current );
+
+            // Register the PI current and Codec factory objects
+            orb.getLocalResolver().register( ORBConstants.PI_CURRENT_NAME, 
+                ClosureFactory.makeConstant( current ) ) ;
+            orb.getLocalResolver().register( ORBConstants.CODEC_FACTORY_NAME, 
+                ClosureFactory.makeConstant( codecFactory ) ) ;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public void initialize() {
-       // If we have any orb initializers, make use of them:
-       if( orb.getORBData().getORBInitializers() != null ) {
-           // Create the ORBInitInfo object to pass to ORB intializers:
-           ORBInitInfoImpl orbInitInfo = createORBInitInfo();
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "initialize" ) ;
+        }
 
-           // Make sure get_slot and set_slot are not called from within
-           // ORB initializers:
-           current.setORBInitializing( true );
+        try {
+            // If we have any orb initializers, make use of them:
+            if( orb.getORBData().getORBInitializers() != null ) {
+                // Create the ORBInitInfo object to pass to ORB intializers:
+                ORBInitInfoImpl orbInitInfo = createORBInitInfo();
 
-           // Call pre_init on all ORB initializers:
-           preInitORBInitializers( orbInitInfo );
+                // Make sure get_slot and set_slot are not called from within
+                // ORB initializers:
+                current.setORBInitializing( true );
 
-           // Call post_init on all ORB initializers:
-           postInitORBInitializers( orbInitInfo );
+                // Call pre_init on all ORB initializers:
+                preInitORBInitializers( orbInitInfo );
 
-           // Proprietary: sort interceptors:
-           interceptorList.sortInterceptors();
+                // Call post_init on all ORB initializers:
+                postInitORBInitializers( orbInitInfo );
 
-           // Re-enable get_slot and set_slot to be called from within
-           // ORB initializers:
-           current.setORBInitializing( false );
+                // Proprietary: sort interceptors:
+                interceptorList.sortInterceptors();
 
-           // Ensure nobody makes any more calls on this object.
-            orbInitInfo.setStage( ORBInitInfoImpl.STAGE_CLOSED );
+                // Re-enable get_slot and set_slot to be called from within
+                // ORB initializers:
+                current.setORBInitializing( false );
 
-           // Set cached flags indicating whether we have interceptors
-           // registered of a given type.
-           hasIORInterceptors = interceptorList.hasInterceptorsOfType(
-               InterceptorList.INTERCEPTOR_TYPE_IOR );
-           // XXX This must always be true, so that using the new generic
-           // RPC framework can pass info between the PI stack and the
-           // framework invocation stack.  Temporary until Harold fixes 
-           // this.  Note that this must never be true until after the
-           // ORBInitializer instances complete executing.
-           //hasClientInterceptors = interceptorList.hasInterceptorsOfType(
-               //InterceptorList.INTERCEPTOR_TYPE_CLIENT );
-           hasClientInterceptors = true;
-           hasServerInterceptors = interceptorList.hasInterceptorsOfType(
-               InterceptorList.INTERCEPTOR_TYPE_SERVER );
+                // Ensure nobody makes any more calls on this object.
+                orbInitInfo.setStage( ORBInitInfoImpl.STAGE_CLOSED );
 
-           // Enable interceptor invoker (not necessary if no interceptors 
-           // are registered).  This should be the last stage of ORB
-           // initialization.
-           interceptorInvoker.setEnabled( true );
-       }
+                // Set cached flags indicating whether we have interceptors
+                // registered of a given type.
+                hasIORInterceptors = interceptorList.hasInterceptorsOfType(
+                    InterceptorList.INTERCEPTOR_TYPE_IOR );
+                // XXX This must always be true, so that using the new generic
+                // RPC framework can pass info between the PI stack and the
+                // framework invocation stack.  Temporary until Harold fixes 
+                // this.  Note that this must never be true until after the
+                // ORBInitializer instances complete executing.
+                //hasClientInterceptors = interceptorList.hasInterceptorsOfType(
+                    //InterceptorList.INTERCEPTOR_TYPE_CLIENT );
+                hasClientInterceptors = true;
+                hasServerInterceptors = interceptorList.hasInterceptorsOfType(
+                    InterceptorList.INTERCEPTOR_TYPE_SERVER );
+
+                // Enable interceptor invoker (not necessary if no interceptors 
+                // are registered).  This should be the last stage of ORB
+                // initialization.
+                interceptorInvoker.setEnabled( true );
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
@@ -299,33 +314,70 @@
      * part of the PIHandler interface, since ORBImpl implements the ORB interface.
      */
     public void destroyInterceptors() {
-        interceptorList.destroyAll();
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "destroyInterceptors" ) ;
+        }
+
+        try {
+            interceptorList.destroyAll();
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    public void objectAdapterCreated( ObjectAdapter oa ) 
-    {
-       if (!hasIORInterceptors)
-           return ;
+    public void objectAdapterCreated( ObjectAdapter oa ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "objectAdapterCreated" ) ;
+        }
 
-       interceptorInvoker.objectAdapterCreated( oa ) ;
+        try {
+            if (!hasIORInterceptors)
+                return ;
+
+            interceptorInvoker.objectAdapterCreated( oa ) ;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public void adapterManagerStateChanged( int managerId,
-       short newState )
-    {
-       if (!hasIORInterceptors)
-           return ;
+       short newState ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "adapterManagerStateChanged" ) ;
+        }
 
-       interceptorInvoker.adapterManagerStateChanged( managerId, newState ) ;
+        try {
+            if (!hasIORInterceptors)
+                return ;
+
+            interceptorInvoker.adapterManagerStateChanged( managerId, newState ) ;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public void adapterStateChanged( ObjectReferenceTemplate[] 
-       templates, short newState )
-    {
-       if (!hasIORInterceptors)
-           return ;
+       templates, short newState ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "adapterStateChanged" ) ;
+        }
 
-       interceptorInvoker.adapterStateChanged( templates, newState ) ;
+        try {
+            if (!hasIORInterceptors)
+                return ;
+
+            interceptorInvoker.adapterStateChanged( templates, newState ) ;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /*
@@ -334,189 +386,316 @@
      *****************/
 
     public void disableInterceptorsThisThread() {
-       if( !hasClientInterceptors ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "disableInterceptorsThisThread" ) ;
+        }
 
-        RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-            threadLocalClientRequestInfoStack.get();
-        infoStack.disableCount++;
+        try {
+            if( !hasClientInterceptors ) return;
+
+            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                threadLocalClientRequestInfoStack.get();
+            infoStack.disableCount++;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     public void enableInterceptorsThisThread() {
-       if( !hasClientInterceptors ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "enableInterceptorsThisThread" ) ;
+        }
 
-        RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-            threadLocalClientRequestInfoStack.get();
-        infoStack.disableCount--;
+        try {
+            if( !hasClientInterceptors ) return;
+
+            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                threadLocalClientRequestInfoStack.get();
+            infoStack.disableCount--;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     public void invokeClientPIStartingPoint() 
-        throws RemarshalException
-    {
-       if( !hasClientInterceptors ) return;
-        if( !isClientPIEnabledForThisThread() ) return;
+        throws RemarshalException {
 
-        // Invoke the starting interception points and record exception
-        // and reply status info in the info object:
-        ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
-        interceptorInvoker.invokeClientInterceptorStartingPoint( info );
-        
-        // Check reply status.  If we will not have another chance later
-        // to invoke the client ending points, do it now.
-        short replyStatus = info.getReplyStatus();
-        if( (replyStatus == SYSTEM_EXCEPTION.value) ||
-            (replyStatus == LOCATION_FORWARD.value) )
-        {
-           // Note: Transport retry cannot happen here since this happens
-           // before the request hits the wire.
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeClientPIStartingPoint" ) ;
+        }
 
-            Exception exception = invokeClientPIEndingPoint( 
-                convertPIReplyStatusToReplyMessage( replyStatus ),
-                info.getException() );
-            if( exception == null ) {
-                // Do not throw anything.  Otherwise, it must be a
-                // SystemException, UserException or RemarshalException.
-            } if( exception instanceof SystemException ) {
-                throw (SystemException)exception;
-            } else if( exception instanceof RemarshalException ) {
-                throw (RemarshalException)exception;
-            } else if( (exception instanceof UserException) ||
-                    (exception instanceof ApplicationException) ) {
-                // It should not be possible for an interceptor to throw 
-               // a UserException.  By asserting instead of throwing the
-               // UserException, we need not declare anything but 
-               // RemarshalException in the throws clause.
-               throw wrapper.exceptionInvalid() ;
+        try {
+            if( !hasClientInterceptors ) return;
+            if( !isClientPIEnabledForThisThread() ) return;
+
+            // Invoke the starting interception points and record exception
+            // and reply status info in the info object:
+            ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
+            interceptorInvoker.invokeClientInterceptorStartingPoint( info );
+            
+            // Check reply status.  If we will not have another chance later
+            // to invoke the client ending points, do it now.
+            short replyStatus = info.getReplyStatus();
+            if( (replyStatus == SYSTEM_EXCEPTION.value) ||
+                (replyStatus == LOCATION_FORWARD.value) ) {
+                // Note: Transport retry cannot happen here since this happens
+                // before the request hits the wire.
+
+                Exception exception = invokeClientPIEndingPoint( 
+                    convertPIReplyStatusToReplyMessage( replyStatus ),
+                    info.getException() );
+                if( exception == null ) {
+                    // Do not throw anything.  Otherwise, it must be a
+                    // SystemException, UserException or RemarshalException.
+                } if( exception instanceof SystemException ) {
+                    throw (SystemException)exception;
+                } else if( exception instanceof RemarshalException ) {
+                    throw (RemarshalException)exception;
+                } else if( (exception instanceof UserException) ||
+                         (exception instanceof ApplicationException) ) {
+                    // It should not be possible for an interceptor to throw 
+                    // a UserException.  By asserting instead of throwing the
+                    // UserException, we need not declare anything but 
+                    // RemarshalException in the throws clause.
+                    throw wrapper.exceptionInvalid() ;
+                }
+            } else if( replyStatus != ClientRequestInfoImpl.UNINITIALIZED ) {
+                throw wrapper.replyStatusNotInit() ;
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
             }
         }
-       else if( replyStatus != ClientRequestInfoImpl.UNINITIALIZED ) {
-           throw wrapper.replyStatusNotInit() ;
-       }
     }
-    
-    public Exception invokeClientPIEndingPoint(
-        int replyStatus, Exception exception )
-    {
-       if( !hasClientInterceptors ) return exception;
-        if( !isClientPIEnabledForThisThread() ) return exception;
 
-        // Translate ReplyMessage.replyStatus into PI replyStatus:
-       // Note: this is also an assertion to make sure a valid replyStatus
-       // is passed in (IndexOutOfBoundsException will be thrown otherwise)
-        short piReplyStatus = REPLY_MESSAGE_TO_PI_REPLY_STATUS[replyStatus];
-        
-        // Invoke the ending interception points and record exception
-        // and reply status info in the info object:
-        ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
-        info.setReplyStatus( piReplyStatus );
-        info.setException( exception );
-        interceptorInvoker.invokeClientInterceptorEndingPoint( info );
-       piReplyStatus = info.getReplyStatus();
+    // Needed when an error forces a retry AFTER initiateClientPIRequest
+    // but BEFORE invokeClientPIStartingPoint.
+    public Exception makeCompletedClientRequest( int replyStatus,
+        Exception exception ) {
 
-        // Check reply status:
-        if( (piReplyStatus == LOCATION_FORWARD.value) ||
-            (piReplyStatus == TRANSPORT_RETRY.value) ) 
-        {
-            // If this is a forward or a retry, reset and reuse 
-            // info object:
-            info.reset();
-            info.setRetryRequest( true );
+        return handleClientPIEndingPoint( replyStatus, exception, false ) ;
+    }
 
-            // ... and return a RemarshalException so the orb internals know
-            exception = new RemarshalException();
+    public Exception invokeClientPIEndingPoint( int replyStatus,
+        Exception exception ) {
+
+        return handleClientPIEndingPoint( replyStatus, exception, true ) ;
+    }
+
+    public Exception handleClientPIEndingPoint(
+        int replyStatus, Exception exception, boolean invokeEndingPoint ) {
+
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "handleClientPIEndingPoint", 
+                "replyStatus", getReplyStatus(replyStatus), 
+                "exception", exception, 
+                "invokeEndingPoint", invokeEndingPoint ) ;
         }
-        else if( (piReplyStatus == SYSTEM_EXCEPTION.value) ||
-                 (piReplyStatus == USER_EXCEPTION.value) ) 
-       {
-            exception = info.getException();
+
+        try {
+            if( !hasClientInterceptors ) return exception;
+            if( !isClientPIEnabledForThisThread() ) return exception;
+
+            // Translate ReplyMessage.replyStatus into PI replyStatus:
+            // Note: this is also an assertion to make sure a valid replyStatus
+            // is passed in (IndexOutOfBoundsException will be thrown otherwise)
+            short piReplyStatus = REPLY_MESSAGE_TO_PI_REPLY_STATUS[replyStatus];
+            
+            // Invoke the ending interception points and record exception
+            // and reply status info in the info object:
+            ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
+            info.setReplyStatus( piReplyStatus );
+            info.setException( exception );
+
+            if (invokeEndingPoint) {
+                interceptorInvoker.invokeClientInterceptorEndingPoint( info );
+                piReplyStatus = info.getReplyStatus();
+            }
+
+            // Check reply status:
+            if( (piReplyStatus == LOCATION_FORWARD.value) ||
+                (piReplyStatus == TRANSPORT_RETRY.value) ) {
+                // If this is a forward or a retry, reset and reuse 
+                // info object:
+                info.reset();
+
+                // fix for 6763340:
+                if (invokeEndingPoint) {
+                    info.setRetryRequest( RetryType.AFTER_RESPONSE ) ;
+                } else {
+                    info.setRetryRequest( RetryType.BEFORE_RESPONSE ) ;
+                }
+
+                // ... and return a RemarshalException so the orb internals know
+                exception = new RemarshalException();
+            } else if( (piReplyStatus == SYSTEM_EXCEPTION.value) ||
+                     (piReplyStatus == USER_EXCEPTION.value) ) {
+
+                exception = info.getException();
+            }
+            
+            return exception;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
-        
-        return exception;
     }
-    
+
     public void initiateClientPIRequest( boolean diiRequest ) {
-       if( !hasClientInterceptors ) return;
-        if( !isClientPIEnabledForThisThread() ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "initiateClientPIRequest" ) ;
+        }
 
-       // Get the most recent info object from the thread local 
-       // ClientRequestInfoImpl stack:
-       RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-           threadLocalClientRequestInfoStack.get();
-       ClientRequestInfoImpl info = null;
-       if( !infoStack.empty() ) 
-           info = infoStack.peek();
+        try {
+            if( !hasClientInterceptors ) return;
+            if( !isClientPIEnabledForThisThread() ) return;
 
-       if( !diiRequest && (info != null) && info.isDIIInitiate() ) {
-           // In RequestImpl.doInvocation we already called 
-           // initiateClientPIRequest( true ), so ignore this initiate.
-           info.setDIIInitiate( false );
-       }
-       else {
-           // If there is no info object or if we are not retrying a request,
-           // push a new ClientRequestInfoImpl on the stack:
-           if( (info == null) || !info.getRetryRequest() ) {
-               info = new ClientRequestInfoImpl( orb );
-               infoStack.push( info );
-               printPush();
-               // Note: the entry count is automatically initialized to 0.
-           }
-           
-           // Reset the retry request flag so that recursive calls will
-           // push a new info object, and bump up entry count so we know
-           // when to pop this info object:
-           info.setRetryRequest( false );
-           info.incrementEntryCount();
+            // Get the most recent info object from the thread local 
+            // ClientRequestInfoImpl stack:
+            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                threadLocalClientRequestInfoStack.get();
+            ClientRequestInfoImpl info = null;
 
-           // If this is a DII request, make sure we ignore the next initiate.
-           if( diiRequest ) {
-               info.setDIIInitiate( true );
-           }
-       }
+            if (!infoStack.empty() ) {
+                info = infoStack.peek();
+            }
+
+            if (!diiRequest && (info != null) && info.isDIIInitiate() ) {
+                // In RequestImpl.doInvocation we already called 
+                // initiateClientPIRequest( true ), so ignore this initiate.
+                if (orb.interceptorDebugFlag) {
+                    dputil.info( "second call for a DII request" ) ;
+                }
+                info.setDIIInitiate( false );
+            } else {
+                // If there is no info object or if we are not retrying a request,
+                // push a new ClientRequestInfoImpl on the stack:
+                if (orb.interceptorDebugFlag) {
+                    dputil.info( "normal call" ) ;
+                }
+
+                // 6763340: don't push unless this is not a retry
+                if( (info == null) || !info.getRetryRequest().isRetry() ) {
+                    info = new ClientRequestInfoImpl( orb );
+                    infoStack.push( info );
+                    if (orb.interceptorDebugFlag) {
+                        dputil.info( "client infoStack was pushed" ) ;
+                    }
+                    // Note: the entry count is automatically initialized to 0.
+                }
+                
+                // Reset the retry request flag so that recursive calls will
+                // push a new info object, and bump up entry count so we know
+                // when to pop this info object:
+                info.setRetryRequest( RetryType.NONE );
+                info.incrementEntryCount();
+
+                // KMC 6763340: I don't know why this wasn't set earlier,
+                // but we do not want a retry to pick up the previous
+                // reply status, so clear it here.  Most likely a new
+                // info was pushed before, so that this was not a problem.
+                info.setReplyStatus( RequestInfoImpl.UNINITIALIZED ) ;
+                
+                // If this is a DII request, make sure we ignore the next initiate.
+                if( diiRequest ) {
+                    info.setDIIInitiate( true );
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     public void cleanupClientPIRequest() {
-       if( !hasClientInterceptors ) return;
-        if( !isClientPIEnabledForThisThread() ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "cleanupClientPIRequest" ) ;
+        }
 
-        ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
-        
-        // If the replyStatus has not yet been set, this is an indication
-        // that the ORB threw an exception before we had a chance to
-        // invoke the client interceptor ending points.
-        //
-        // _REVISIT_ We cannot handle any exceptions or ForwardRequests
-        // flagged by the ending points here because there is no way
-        // to gracefully handle this in any of the calling code.  
-        // This is a rare corner case, so we will ignore this for now.
-        short replyStatus = info.getReplyStatus();
-        if( replyStatus == info.UNINITIALIZED ) {
-           invokeClientPIEndingPoint( ReplyMessage.SYSTEM_EXCEPTION,
-               wrapper.unknownRequestInvoke( 
-                   CompletionStatus.COMPLETED_MAYBE ) ) ;
-        }
-        
-        // Decrement entry count, and if it is zero, pop it from the stack.
-        info.decrementEntryCount();
-        if( info.getEntryCount() == 0 ) {
-           RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-               threadLocalClientRequestInfoStack.get();
-            infoStack.pop();
-           printPop();
+        try {
+            if( !hasClientInterceptors ) return;
+            if( !isClientPIEnabledForThisThread() ) return;
+
+            ClientRequestInfoImpl info = peekClientRequestInfoImplStack();
+            RetryType rt = info.getRetryRequest() ;
+
+            // fix for 6763340
+            if (!rt.equals( RetryType.BEFORE_RESPONSE )) {
+                // If the replyStatus has not yet been set, this is an indication
+                // that the ORB threw an exception before we had a chance to
+                // invoke the client interceptor ending points.
+                //
+                // _REVISIT_ We cannot handle any exceptions or ForwardRequests
+                // flagged by the ending points here because there is no way
+                // to gracefully handle this in any of the calling code.  
+                // This is a rare corner case, so we will ignore this for now.
+                short replyStatus = info.getReplyStatus();
+                if (replyStatus == info.UNINITIALIZED ) {
+                    invokeClientPIEndingPoint( ReplyMessage.SYSTEM_EXCEPTION,
+                        wrapper.unknownRequestInvoke( 
+                            CompletionStatus.COMPLETED_MAYBE ) ) ;
+                }
+            }
+            
+            // Decrement entry count, and if it is zero, pop it from the stack.
+            info.decrementEntryCount();
+            
+            // fix for 6763340, and probably other cases (non-recursive retry)
+            if (info.getEntryCount() == 0 && !info.getRetryRequest().isRetry()) {
+                RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                    threadLocalClientRequestInfoStack.get();
+                infoStack.pop();
+                if (orb.interceptorDebugFlag) {
+                    dputil.info( "client infoStack was popped" ) ;
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
 
     public void setClientPIInfo(CorbaMessageMediator messageMediator)
     {
-       if( !hasClientInterceptors ) return;
-        if( !isClientPIEnabledForThisThread() ) return;
-        
-        peekClientRequestInfoImplStack().setInfo(messageMediator);
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setClientPIInfo" ) ;
+        }
+
+        try {
+            if( !hasClientInterceptors ) return;
+            if( !isClientPIEnabledForThisThread() ) return;
+            
+            peekClientRequestInfoImplStack().setInfo(messageMediator);
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     public void setClientPIInfo( RequestImpl requestImpl ) {
-       if( !hasClientInterceptors ) return;
-        if( !isClientPIEnabledForThisThread() ) return;
-        
-        peekClientRequestInfoImplStack().setDIIRequest( requestImpl );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setClientPIInfo" ) ;
+        }
+
+        try {
+            if( !hasClientInterceptors ) return;
+            if( !isClientPIEnabledForThisThread() ) return;
+            
+            peekClientRequestInfoImplStack().setDIIRequest( requestImpl );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /*
@@ -524,176 +703,281 @@
      * Server PI hooks
      *****************/
     
-    public void invokeServerPIStartingPoint() 
-    {
-       if( !hasServerInterceptors ) return;
+    public void invokeServerPIStartingPoint() {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        interceptorInvoker.invokeServerInterceptorStartingPoint( info );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeServerPIStartingPoint" ) ;
+        }
 
-       // Handle SystemException or ForwardRequest:
-       serverPIHandleExceptions( info );
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            interceptorInvoker.invokeServerInterceptorStartingPoint( info );
+
+            // Handle SystemException or ForwardRequest:
+            serverPIHandleExceptions( info );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    public void invokeServerPIIntermediatePoint() 
-    {
-       if( !hasServerInterceptors ) return;
+    public void invokeServerPIIntermediatePoint() {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        interceptorInvoker.invokeServerInterceptorIntermediatePoint( info );
-        
-        // Clear servant from info object so that the user has control over
-        // its lifetime:
-        info.releaseServant();
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokeServerPIIntermediatePoint" ) ;
+        }
 
-       // Handle SystemException or ForwardRequest:
-       serverPIHandleExceptions( info );
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            interceptorInvoker.invokeServerInterceptorIntermediatePoint( info );
+            
+            // Clear servant from info object so that the user has control over
+            // its lifetime:
+            info.releaseServant();
+
+            // Handle SystemException or ForwardRequest:
+            serverPIHandleExceptions( info );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
-    public void invokeServerPIEndingPoint( ReplyMessage replyMessage ) 
-    {
-       if( !hasServerInterceptors ) return;
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+    public void invokeServerPIEndingPoint( ReplyMessage replyMessage ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "invokerServerPIEndingPoint" ) ;
+        }
 
-       // REVISIT: This needs to be done "early" for the following workaround.
-       info.setReplyMessage( replyMessage );
+        try {
 
-       // REVISIT: This was done inside of invokeServerInterceptorEndingPoint
-       // but needs to be here for now.  See comment in that method for why.
-       info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
+            if( !hasServerInterceptors ) return;
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
 
-        // It is possible we might have entered this method more than
-        // once (e.g. if an ending point threw a SystemException, then
-        // a new ServerResponseImpl is created).
-        if( !info.getAlreadyExecuted() ) {
-           int replyStatus = replyMessage.getReplyStatus();
+            // REVISIT: This needs to be done "early" for the following workaround.
+            info.setReplyMessage( replyMessage );
 
-            // Translate ReplyMessage.replyStatus into PI replyStatus:
-            // Note: this is also an assertion to make sure a valid 
-            // replyStatus is passed in (IndexOutOfBoundsException will be 
-            // thrown otherwise)
-            short piReplyStatus = 
-                REPLY_MESSAGE_TO_PI_REPLY_STATUS[replyStatus];
+            // REVISIT: This was done inside of invokeServerInterceptorEndingPoint
+            // but needs to be here for now.  See comment in that method for why.
+            info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING );
 
-           // Make forwarded IOR available to interceptors, if applicable:
-           if( ( piReplyStatus == LOCATION_FORWARD.value ) ||
-               ( piReplyStatus == TRANSPORT_RETRY.value ) ) 
-           {
-               info.setForwardRequest( replyMessage.getIOR() );
-           }
+            // It is possible we might have entered this method more than
+            // once (e.g. if an ending point threw a SystemException, then
+            // a new ServerResponseImpl is created).
+            if( !info.getAlreadyExecuted() ) {
+                int replyStatus = replyMessage.getReplyStatus();
 
-           // REVISIT: Do early above for now.
-           // Make reply message available to interceptors:
-           //info.setReplyMessage( replyMessage );
+                // Translate ReplyMessage.replyStatus into PI replyStatus:
+                // Note: this is also an assertion to make sure a valid 
+                // replyStatus is passed in (IndexOutOfBoundsException will be 
+                // thrown otherwise)
+                short piReplyStatus = 
+                    REPLY_MESSAGE_TO_PI_REPLY_STATUS[replyStatus];
 
-            // Remember exception so we can tell if an interceptor changed it.
-            Exception prevException = info.getException();
+                // Make forwarded IOR available to interceptors, if applicable:
+                if( ( piReplyStatus == LOCATION_FORWARD.value ) ||
+                    ( piReplyStatus == TRANSPORT_RETRY.value ) ) 
+                {
+                    info.setForwardRequest( replyMessage.getIOR() );
+                }
 
-           // _REVISIT_ We do not have access to the User Exception at
-           // this point, so treat it as an UNKNOWN for now.
-           // Note that if this is a DSI call, we do have the user exception.
-           if( !info.isDynamic() && 
-               (piReplyStatus == USER_EXCEPTION.value) ) 
-           {
-               info.setException( omgWrapper.unknownUserException( 
-                   CompletionStatus.COMPLETED_MAYBE ) ) ;
-           }
-            
-            // Invoke the ending interception points:
-            info.setReplyStatus( piReplyStatus );
-            interceptorInvoker.invokeServerInterceptorEndingPoint( info );
-            short newPIReplyStatus = info.getReplyStatus();
-            Exception newException = info.getException();
-            
-            // Check reply status.  If an interceptor threw a SystemException
-            // and it is different than the one that we came in with,
-            // rethrow it so the proper response can be constructed:
-            if( ( newPIReplyStatus == SYSTEM_EXCEPTION.value ) &&
-                ( newException != prevException ) ) 
-            {
-                throw (SystemException)newException;
+                // REVISIT: Do early above for now.
+                // Make reply message available to interceptors:
+                //info.setReplyMessage( replyMessage );
+
+                // Remember exception so we can tell if an interceptor changed it.
+                Exception prevException = info.getException();
+
+                // _REVISIT_ We do not have access to the User Exception at
+                // this point, so treat it as an UNKNOWN for now.
+                // Note that if this is a DSI call, we do have the user exception.
+                if( !info.isDynamic() && 
+                    (piReplyStatus == USER_EXCEPTION.value) ) 
+                {
+                    info.setException( omgWrapper.unknownUserException( 
+                        CompletionStatus.COMPLETED_MAYBE ) ) ;
+                }
+                
+                // Invoke the ending interception points:
+                info.setReplyStatus( piReplyStatus );
+                interceptorInvoker.invokeServerInterceptorEndingPoint( info );
+                short newPIReplyStatus = info.getReplyStatus();
+                Exception newException = info.getException();
+                
+                // Check reply status.  If an interceptor threw a SystemException
+                // and it is different than the one that we came in with,
+                // rethrow it so the proper response can be constructed:
+                if( ( newPIReplyStatus == SYSTEM_EXCEPTION.value ) &&
+                    ( newException != prevException ) ) 
+                {
+                    throw (SystemException)newException;
+                }
+
+                // If we are to forward the location:
+                if( newPIReplyStatus == LOCATION_FORWARD.value ) {
+                    if( piReplyStatus != LOCATION_FORWARD.value ) {
+                        // Treat a ForwardRequest as a ForwardException.
+                        IOR ior = info.getForwardRequestIOR();
+                        throw new ForwardException( orb, ior ) ;
+                    }
+                    else if( info.isForwardRequestRaisedInEnding() ) {
+                        // Treat a ForwardRequest by changing the IOR.
+                        replyMessage.setIOR( info.getForwardRequestIOR() );
+                    }
+                }
             }
-
-           // If we are to forward the location:
-           if( newPIReplyStatus == LOCATION_FORWARD.value ) {
-               if( piReplyStatus != LOCATION_FORWARD.value ) {
-                   // Treat a ForwardRequest as a ForwardException.
-                    IOR ior = info.getForwardRequestIOR();
-                   throw new ForwardException( orb, ior ) ;
-               }
-               else if( info.isForwardRequestRaisedInEnding() ) {
-                   // Treat a ForwardRequest by changing the IOR.
-                    replyMessage.setIOR( info.getForwardRequestIOR() );
-               }
-           }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
     
     public void setServerPIInfo( Exception exception ) {
-       if( !hasServerInterceptors ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setServerPIInfo" ) ;
+        }
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        info.setException( exception );
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            info.setException( exception );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    public void setServerPIInfo( NVList arguments )
-    {
-       if( !hasServerInterceptors ) return;
+    public void setServerPIInfo( NVList arguments ) {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        info.setDSIArguments( arguments );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setServerPIInfo" ) ;
+        }
+
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            info.setDSIArguments( arguments );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    public void setServerPIExceptionInfo( Any exception )
-    {
-       if( !hasServerInterceptors ) return;
+    public void setServerPIExceptionInfo( Any exception ) {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        info.setDSIException( exception );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "SetServerPIExceptionInfo" ) ;
+        }
+
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            info.setDSIException( exception );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
-    public void setServerPIInfo( Any result )
-    {
-       if( !hasServerInterceptors ) return;
+    public void setServerPIInfo( Any result ) {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        info.setDSIResult( result );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setServerPIInfo" ) ;
+        }
+
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            info.setDSIResult( result );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public void initializeServerPIInfo( CorbaMessageMediator request,
-       ObjectAdapter oa, byte[] objectId, ObjectKeyTemplate oktemp ) 
-    {
-       if( !hasServerInterceptors ) return;
+       ObjectAdapter oa, byte[] objectId, ObjectKeyTemplate oktemp ) {
 
-        RequestInfoStack<ServerRequestInfoImpl> infoStack = 
-            threadLocalServerRequestInfoStack.get();
-        ServerRequestInfoImpl info = new ServerRequestInfoImpl( orb );
-       infoStack.push( info );
-       printPush();
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "initializeServerPIInfo" ) ;
+        }
 
-       // Notify request object that once response is constructed, make
-       // sure we execute ending points.
-        request.setExecutePIInResponseConstructor( true );
+        try {
 
-        info.setInfo( request, oa, objectId, oktemp );
+            if( !hasServerInterceptors ) return;
+
+            RequestInfoStack<ServerRequestInfoImpl> infoStack = 
+                threadLocalServerRequestInfoStack.get();
+            ServerRequestInfoImpl info = new ServerRequestInfoImpl( orb );
+            infoStack.push( info );
+            if (orb.interceptorDebugFlag) {
+                dputil.info( "server infoStack was pushed" ) ;
+            }
+
+            // Notify request object that once response is constructed, make
+            // sure we execute ending points.
+            request.setExecutePIInResponseConstructor( true );
+
+            info.setInfo( request, oa, objectId, oktemp );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     public void setServerPIInfo( java.lang.Object servant, 
-                                         String targetMostDerivedInterface ) 
-    {
-       if( !hasServerInterceptors ) return;
+        String targetMostDerivedInterface ) {
 
-        ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
-        info.setInfo( servant, targetMostDerivedInterface );
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "setServerPIInfo" ) ;
+        }
+
+        try {
+            if( !hasServerInterceptors ) return;
+
+            ServerRequestInfoImpl info = peekServerRequestInfoImplStack();
+            info.setInfo( servant, targetMostDerivedInterface );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public void cleanupServerPIRequest() {
-       if( !hasServerInterceptors ) return;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "cleanupServerPIRequest" ) ;
+        }
 
-        RequestInfoStack<ServerRequestInfoImpl> infoStack = 
-            threadLocalServerRequestInfoStack.get();
-       infoStack.pop();
-       printPop();
+        try {
+            if( !hasServerInterceptors ) return;
+
+            RequestInfoStack<ServerRequestInfoImpl> infoStack = 
+                threadLocalServerRequestInfoStack.get();
+            infoStack.pop();
+            if (orb.interceptorDebugFlag) {
+                dputil.info( "server infoStack was popped" ) ;
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /* 
@@ -708,20 +992,29 @@
      * <p>
      * This method will NOT work for ending points.
      */
-    private void serverPIHandleExceptions( ServerRequestInfoImpl info ) 
-    {
-        int endingPointCall = info.getEndingPointCall();
-        if(endingPointCall == ServerRequestInfoImpl.CALL_SEND_EXCEPTION) {
-            // If a system exception was thrown, throw it to caller:
-            throw (SystemException)info.getException();
+    private void serverPIHandleExceptions( ServerRequestInfoImpl info ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "serverPIHandleExceptions" ) ;
         }
-        else if( (endingPointCall == ServerRequestInfoImpl.CALL_SEND_OTHER) &&
-                 (info.getForwardRequestException() != null) )
-        {
-            // If an interceptor throws a forward request, convert it
-            // into a ForwardException for easier handling:
-            IOR ior = info.getForwardRequestIOR();
-           throw new ForwardException( orb, ior );
+
+        try {
+            int endingPointCall = info.getEndingPointCall();
+            if(endingPointCall == ServerRequestInfoImpl.CALL_SEND_EXCEPTION) {
+                // If a system exception was thrown, throw it to caller:
+                throw (SystemException)info.getException();
+            }
+            else if( (endingPointCall == ServerRequestInfoImpl.CALL_SEND_OTHER) &&
+                     (info.getForwardRequestException() != null) )
+            {
+                // If an interceptor throws a forward request, convert it
+                // into a ForwardException for easier handling:
+                IOR ior = info.getForwardRequestIOR();
+                throw new ForwardException( orb, ior );
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
 
@@ -733,14 +1026,24 @@
      * conditions.
      */
     private int convertPIReplyStatusToReplyMessage( short replyStatus ) {
-        int result = 0;
-        for( int i = 0; i < REPLY_MESSAGE_TO_PI_REPLY_STATUS.length; i++ ) {
-            if( REPLY_MESSAGE_TO_PI_REPLY_STATUS[i] == replyStatus ) {
-                result = i;
-               break;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "convertPIReplyStatusToReplyMessage" ) ;
+        }
+
+        try {
+            int result = 0;
+            for( int i = 0; i < REPLY_MESSAGE_TO_PI_REPLY_STATUS.length; i++ ) {
+                if( REPLY_MESSAGE_TO_PI_REPLY_STATUS[i] == replyStatus ) {
+                    result = i;
+                    break;
+                }
+            }
+            return result;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
             }
         }
-        return result;
     }
     
     /** 
@@ -749,16 +1052,26 @@
      * the Info stack is empty.
      */
     private ClientRequestInfoImpl peekClientRequestInfoImplStack() {
-        RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-            threadLocalClientRequestInfoStack.get();
-        ClientRequestInfoImpl info = null;
-        if( !infoStack.empty() ) {
-           info = infoStack.peek();
-       } else {
-           throw wrapper.clientInfoStackNull() ;
-       }
-        
-        return info;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "peekClientRequestInfoImplStack" ) ;
+        }
+
+        try {
+            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                threadLocalClientRequestInfoStack.get();
+            ClientRequestInfoImpl info = null;
+            if( !infoStack.empty() ) {
+                info = infoStack.peek();
+            } else {
+                throw wrapper.clientInfoStackNull() ;
+            }
+            
+            return info;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /** 
@@ -766,17 +1079,27 @@
      * top of the ThreadLocal stack.  Returns null if there are none.
      */
     private ServerRequestInfoImpl peekServerRequestInfoImplStack() {
-        RequestInfoStack<ServerRequestInfoImpl> infoStack = 
-            threadLocalServerRequestInfoStack.get();
-        ServerRequestInfoImpl info = null;
-
-        if( !infoStack.empty() ) {
-            info = infoStack.peek();
-        } else {
-           throw wrapper.serverInfoStackNull() ;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "peekServerRequestInfoImplStack" ) ;
         }
 
-        return info;
+        try {
+            RequestInfoStack<ServerRequestInfoImpl> infoStack = 
+                threadLocalServerRequestInfoStack.get();
+            ServerRequestInfoImpl info = null;
+
+            if( !infoStack.empty() ) {
+                info = infoStack.peek();
+            } else {
+                throw wrapper.serverInfoStackNull() ;
+            }
+
+            return info;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
@@ -784,59 +1107,89 @@
      * for requests on this thread. 
      */
     private boolean isClientPIEnabledForThisThread() {
-        RequestInfoStack<ClientRequestInfoImpl> infoStack = 
-            threadLocalClientRequestInfoStack.get();
-        return (infoStack.disableCount == 0);
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "isClientPIEnabledForThisThread" ) ;
+        }
+
+        try {
+            RequestInfoStack<ClientRequestInfoImpl> infoStack = 
+                threadLocalClientRequestInfoStack.get();
+            return (infoStack.disableCount == 0);
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
     
     /**
      * Call pre_init on all ORB initializers
      */
     private void preInitORBInitializers( ORBInitInfoImpl info ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "perInitORBInitializers" ) ;
+        }
 
-       // Inform ORBInitInfo we are in pre_init stage
-        info.setStage( ORBInitInfoImpl.STAGE_PRE_INIT );
+        try {
 
-       // Step through each initializer instantiation and call its 
-       // pre_init.  Ignore any exceptions.
-       for( int i = 0; i < orb.getORBData().getORBInitializers().length; 
-           i++ ) {
-           ORBInitializer init = orb.getORBData().getORBInitializers()[i];
-           if( init != null ) {
-               try {
-                   init.pre_init( info );
-               }
-               catch( Exception e ) {
-                   // As per orbos/99-12-02, section 9.3.1.2, "If there are 
-                   // any exceptions, the ORB shall ignore them and proceed."
-               }
-           }
-       }
+            // Inform ORBInitInfo we are in pre_init stage
+            info.setStage( ORBInitInfoImpl.STAGE_PRE_INIT );
+
+            // Step through each initializer instantiation and call its 
+            // pre_init.  Ignore any exceptions.
+            for( int i = 0; i < orb.getORBData().getORBInitializers().length; 
+                i++ ) {
+                ORBInitializer init = orb.getORBData().getORBInitializers()[i];
+                if( init != null ) {
+                    try {
+                        init.pre_init( info );
+                    }
+                    catch( Exception e ) {
+                        // As per orbos/99-12-02, section 9.3.1.2, "If there are 
+                        // any exceptions, the ORB shall ignore them and proceed."
+                    }
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
      * Call post_init on all ORB initializers
      */
     private void postInitORBInitializers( ORBInitInfoImpl info ) {
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "postInitORBInitializers" ) ;
+        }
 
-       // Inform ORBInitInfo we are in post_init stage
-        info.setStage( ORBInitInfoImpl.STAGE_POST_INIT );
+        try {
 
-       // Step through each initializer instantiation and call its post_init.
-       // Ignore any exceptions.
-       for( int i = 0; i < orb.getORBData().getORBInitializers().length; 
-           i++ ) {
-           ORBInitializer init = orb.getORBData().getORBInitializers()[i];
-           if( init != null ) {
-               try {
-                   init.post_init( info );
-               }
-               catch( Exception e ) {
-                   // As per orbos/99-12-02, section 9.3.1.2, "If there are 
-                   // any exceptions, the ORB shall ignore them and proceed."
-               }
-           }
-       }
+            // Inform ORBInitInfo we are in post_init stage
+            info.setStage( ORBInitInfoImpl.STAGE_POST_INIT );
+
+            // Step through each initializer instantiation and call its post_init.
+            // Ignore any exceptions.
+            for( int i = 0; i < orb.getORBData().getORBInitializers().length; 
+                i++ ) {
+                ORBInitializer init = orb.getORBData().getORBInitializers()[i];
+                if( init != null ) {
+                    try {
+                        init.post_init( info );
+                    }
+                    catch( Exception e ) {
+                        // As per orbos/99-12-02, section 9.3.1.2, "If there are 
+                        // any exceptions, the ORB shall ignore them and proceed."
+                    }
+                }
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /** 
@@ -844,18 +1197,28 @@
      * pre_init and post_init methods
      */
     private ORBInitInfoImpl createORBInitInfo() {
-       ORBInitInfoImpl result = null;
-       
-       // arguments comes from set_parameters.  May be null.
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "createORBInitInfo" ) ;
+        }
 
-       // _REVISIT_ The spec does not specify which ID this is to be.
-       // We currently get this from the corba.ORB, which reads it from
-       // the ORB_ID_PROPERTY property.
-       String orbId = orb.getORBData().getORBId() ;
+        try {
+            ORBInitInfoImpl result = null;
+            
+            // arguments comes from set_parameters.  May be null.
 
-       result = new ORBInitInfoImpl( orb, arguments, orbId, codecFactory );
+            // _REVISIT_ The spec does not specify which ID this is to be.
+            // We currently get this from the corba.ORB, which reads it from
+            // the ORB_ID_PROPERTY property.
+            String orbId = orb.getORBData().getORBId() ;
 
-       return result;
+            result = new ORBInitInfoImpl( orb, arguments, orbId, codecFactory );
+
+            return result;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     /**
@@ -871,22 +1234,32 @@
      *     name already exists for the given type.
      */
     public void register_interceptor( Interceptor interceptor, int type ) 
-       throws DuplicateName
-    {
-       // We will assume interceptor is not null, since it is called
-       // internally.
-       if( (type >= InterceptorList.NUM_INTERCEPTOR_TYPES) || (type < 0) ) {
-           throw wrapper.typeOutOfRange( Integer.valueOf( type ) ) ;
-       }
+       throws DuplicateName {
 
-        String interceptorName = interceptor.name();
-
-        if( interceptorName == null ) {
-           throw wrapper.nameNull() ;
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "register_interceptor" ) ;
         }
 
-       // Register with interceptor list:
-       interceptorList.register_interceptor( interceptor, type );
+        try {
+            // We will assume interceptor is not null, since it is called
+            // internally.
+            if( (type >= InterceptorList.NUM_INTERCEPTOR_TYPES) || (type < 0) ) {
+                throw wrapper.typeOutOfRange( Integer.valueOf( type ) ) ;
+            }
+
+            String interceptorName = interceptor.name();
+
+            if( interceptorName == null ) {
+                throw wrapper.nameNull() ;
+            }
+
+            // Register with interceptor list:
+            interceptorList.register_interceptor( interceptor, type );
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
+        }
     }
 
     public Current getPICurrent( ) {
@@ -912,27 +1285,37 @@
      *  this method to com.sun.corba.ee.spi.orb.ORB. 
      */
     public org.omg.CORBA.Policy create_policy(int type, org.omg.CORBA.Any val)
-        throws org.omg.CORBA.PolicyError
-    {
-        if( val == null ) {
-            nullParam( );
+        throws org.omg.CORBA.PolicyError {
+
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "create_policy" ) ;
         }
 
-        if( policyFactoryTable == null ) {
-            throw new org.omg.CORBA.PolicyError(
-                "There is no PolicyFactory Registered for type " + type, 
-               BAD_POLICY.value );
+        try {
+            if( val == null ) {
+                nullParam( );
+            }
+
+            if( policyFactoryTable == null ) {
+                throw new org.omg.CORBA.PolicyError(
+                    "There is no PolicyFactory Registered for type " + type, 
+                    BAD_POLICY.value );
+            }
+
+            PolicyFactory factory = policyFactoryTable.get( type );
+            if( factory == null ) {
+                throw new org.omg.CORBA.PolicyError(
+                    " Could Not Find PolicyFactory for the Type " + type, 
+                    BAD_POLICY.value);
+            }
+
+            org.omg.CORBA.Policy policy = factory.create_policy( type, val );
+            return policy;
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
-
-        PolicyFactory factory = policyFactoryTable.get( type );
-        if( factory == null ) {
-            throw new org.omg.CORBA.PolicyError(
-                " Could Not Find PolicyFactory for the Type " + type, 
-                BAD_POLICY.value);
-        }
-
-        org.omg.CORBA.Policy policy = factory.create_policy( type, val );
-        return policy;
     }
 
     /** This method registers the Policy Factory in the policyFactoryTable,
@@ -940,15 +1323,25 @@
      *  it is used internally by the  Interceptors.
      */
     public void registerPolicyFactory( int type, PolicyFactory factory ) {
-        if( policyFactoryTable == null ) {
-            policyFactoryTable = new HashMap<Integer,PolicyFactory>();
+        if (orb.interceptorDebugFlag) {
+            dputil.enter( "registerPolicyFactory" ) ;
         }
-        Integer key = Integer.valueOf( type );
-        PolicyFactory val = policyFactoryTable.get( key );
-        if (val == null) {
-            policyFactoryTable.put( key, factory );
-        } else { 
-           throw omgWrapper.policyFactoryRegFailed( Integer.valueOf( type ) ) ;
+
+        try {
+            if( policyFactoryTable == null ) {
+                policyFactoryTable = new HashMap<Integer,PolicyFactory>();
+            }
+            Integer key = Integer.valueOf( type );
+            PolicyFactory val = policyFactoryTable.get( key );
+            if (val == null) {
+                policyFactoryTable.put( key, factory );
+            } else { 
+                throw omgWrapper.policyFactoryRegFailed( Integer.valueOf( type ) ) ;
+            }
+        } finally {
+            if (orb.interceptorDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
     
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/interceptors/PINoOpHandlerImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/interceptors/PINoOpHandlerImpl.java       Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/interceptors/PINoOpHandlerImpl.java       Mon Jul 06 12:05:55 2009 -0700
@@ -120,6 +120,12 @@
     {
         return null;
     }
+
+    public Exception makeCompletedClientRequest(
+        int replyStatus, Exception exception )
+    {
+        return null;
+    }
     
     public void initiateClientPIRequest( boolean diiRequest ) {
     }
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/interceptors/RequestInfoImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/interceptors/RequestInfoImpl.java Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/interceptors/RequestInfoImpl.java Mon Jul 06 12:05:55 2009 -0700
@@ -41,40 +41,26 @@
 import java.lang.reflect.InvocationTargetException ;
 
 import java.util.Map ;
-import java.util.HashMap ;
 
 import org.omg.PortableInterceptor.ForwardRequest;
 import org.omg.PortableInterceptor.InvalidSlot;
 import org.omg.PortableInterceptor.RequestInfo;
-import org.omg.PortableInterceptor.LOCATION_FORWARD;
-import org.omg.IOP.TaggedProfile;
-import org.omg.IOP.TaggedComponent;
 import org.omg.IOP.ServiceContextHelper;
 import org.omg.Messaging.SYNC_WITH_TRANSPORT;
 import org.omg.CORBA.ParameterMode;
 
 import org.omg.CORBA.Any;
 import org.omg.CORBA.BAD_INV_ORDER;
-import org.omg.CORBA.BAD_PARAM;
 import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.Context;
-import org.omg.CORBA.ContextList;
-import org.omg.CORBA.CTX_RESTRICT_SCOPE;
-import org.omg.CORBA.ExceptionList;
-import org.omg.CORBA.INTERNAL;
 import org.omg.CORBA.LocalObject;
 import org.omg.CORBA.NamedValue;
-import org.omg.CORBA.NO_IMPLEMENT;
-import org.omg.CORBA.NO_RESOURCES;
 import org.omg.CORBA.NVList;
 import org.omg.CORBA.Object;
-import org.omg.CORBA.Policy;
 import org.omg.CORBA.SystemException;
 import org.omg.CORBA.TypeCode;
 import org.omg.CORBA.UNKNOWN;
 import org.omg.CORBA.UserException;
 import org.omg.CORBA.portable.ApplicationException;
-import org.omg.CORBA.portable.Delegate;
 import org.omg.CORBA.portable.InputStream;
              
 import org.omg.Dynamic.Parameter;
@@ -95,10 +81,10 @@
 
 import com.sun.corba.ee.spi.orbutil.ORBClassLoader;
 
-import com.sun.corba.ee.impl.encoding.CDRInputStream_1_0;
 import com.sun.corba.ee.impl.encoding.EncapsOutputStream;
 
 import com.sun.corba.ee.impl.orbutil.ORBUtility;
+import com.sun.corba.ee.impl.orbutil.DprintUtil;
 
 import com.sun.corba.ee.impl.util.RepositoryId;
 
@@ -121,6 +107,7 @@
 
     // The ORB from which to get PICurrent and other info
     protected ORB myORB;
+    protected DprintUtil dputil ;
     protected InterceptorsSystemException wrapper ;
     protected OMGSystemException stdWrapper ;
 
@@ -199,7 +186,7 @@
         startingPointCall = 0;
         intermediatePointCall = 0;
         endingPointCall = 0;
-        replyStatus = UNINITIALIZED;
+        setReplyStatus( UNINITIALIZED ) ;
         currentExecutionPoint = EXECUTION_POINT_STARTING;
         alreadyExecuted = false;
        connection = null;
@@ -249,6 +236,7 @@
         super();
         
         this.myORB = myORB;
+        dputil = new DprintUtil(this) ;
        wrapper = myORB.getLogWrapperTable().get_RPC_PROTOCOL_Interceptors() ;
        stdWrapper = myORB.getLogWrapperTable().get_RPC_PROTOCOL_OMG() ;
 
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/orb/ORBImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/orb/ORBImpl.java  Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/orb/ORBImpl.java  Mon Jul 06 12:05:55 2009 -0700
@@ -1948,7 +1948,9 @@
            }
            clientInvocationInfo.decrementEntryCount();
            entryCount = clientInvocationInfo.getEntryCount();
-           if (clientInvocationInfo.getEntryCount() == 0) {
+           if (clientInvocationInfo.getEntryCount() == 0 
+                && !clientInvocationInfo.isRetryInvocation()) {
+
                invocationInfoStack.pop();
                if (subcontractDebugFlag) {
                    dprint(".releaseOrDecrementInvocationInfo: pop");
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/orbutil/ORBUtility.java
--- a/src/share/classes/com/sun/corba/ee/impl/orbutil/ORBUtility.java   Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/orbutil/ORBUtility.java   Mon Jul 06 12:05:55 2009 -0700
@@ -272,8 +272,6 @@
 
     private static ValueHandler vhandler = 
         new ValueHandlerImpl() ;
-    private static ValueHandler vhandler_1_3_1 = 
-        new ValueHandlerImpl_1_3_1() ;
 
     /**
      * Creates the correct ValueHandler for the given ORB, 
@@ -282,18 +280,6 @@
      * Util.createValueHandler.
      */
     public static ValueHandler createValueHandler(ORB orb) {
-
-        if (orb == null)
-           return vhandler;
-
-        ORBVersion version = orb.getORBVersion();
-
-        if (version == null)
-            return vhandler;
-
-        if (version.equals(ORBVersionFactory.getNEW()))
-            return vhandler_1_3_1;
-
         return vhandler;
     }
 
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/orbutil/RepIdDelegator.java
--- a/src/share/classes/com/sun/corba/ee/impl/orbutil/RepIdDelegator.java       Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/orbutil/RepIdDelegator.java       Mon Jul 06 12:05:55 2009 -0700
@@ -36,11 +36,9 @@
 
 package com.sun.corba.ee.impl.orbutil;
 
-import org.omg.CORBA.ORB;
 
 import java.io.Serializable;
 
-import java.util.Hashtable;
 
 import java.net.MalformedURLException;
 
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/orbutil/RepositoryIdFactory.java
--- a/src/share/classes/com/sun/corba/ee/impl/orbutil/RepositoryIdFactory.java  Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/orbutil/RepositoryIdFactory.java  Mon Jul 06 12:05:55 2009 -0700
@@ -36,14 +36,10 @@
 
 package com.sun.corba.ee.impl.orbutil;
 
-import com.sun.corba.ee.spi.orb.ORBVersion;
 import com.sun.corba.ee.spi.orb.ORB;
 
 public abstract class RepositoryIdFactory
 {
-    private static final RepIdDelegator_1_3_1 ladybirdDelegator
-        = new RepIdDelegator_1_3_1();
-
     private static final RepIdDelegator currentDelegator
         = new RepIdDelegator();
 
@@ -61,19 +57,7 @@
      */
     public static RepositoryIdStrings getRepIdStringsFactory(ORB orb)
     {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
+        return currentDelegator;
     }
 
     /**
@@ -90,18 +74,6 @@
      */
     public static RepositoryIdUtility getRepIdUtility(ORB orb)
     {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
+        return currentDelegator;
     }
 }
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/impl/protocol/CorbaClientRequestDispatcherImpl.java
--- a/src/share/classes/com/sun/corba/ee/impl/protocol/CorbaClientRequestDispatcherImpl.java    Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/impl/protocol/CorbaClientRequestDispatcherImpl.java    Mon Jul 06 12:05:55 2009 -0700
@@ -120,6 +120,8 @@
 import com.sun.corba.ee.spi.orbutil.ORBConstants;
 import com.sun.corba.ee.impl.orbutil.newtimer.generated.TimingPoints;
 
+import com.sun.corba.ee.impl.orbutil.DprintUtil;
+
 import com.sun.corba.ee.impl.protocol.giopmsgheaders.ReplyMessage;
 import com.sun.corba.ee.impl.protocol.giopmsgheaders.KeyAddr;
 import com.sun.corba.ee.impl.protocol.giopmsgheaders.ProfileAddr;
@@ -137,6 +139,8 @@
 {
     // Used for locking
     private Object lock = new Object();
+    private DprintUtil dputil = new DprintUtil( this ) ;
+
     private ORBVersionServiceContext ovsc = 
                    ServiceContextDefaults.makeORBVersionServiceContext();
 
@@ -147,26 +151,21 @@
     public OutputObject beginRequest(Object self, String opName, 
        boolean isOneWay, ContactInfo contactInfo) {
 
-       ORB orb = null;
-       TimingPoints tp = null ;
+        final CorbaContactInfo corbaContactInfo = (CorbaContactInfo) contactInfo;
+        final ORB orb = (ORB)contactInfo.getBroker();
+
+        if (orb.subcontractDebugFlag) {
+            dputil.enter("beginRequest", "op", opName, "isOneWay", isOneWay, 
+                "contactInfo", contactInfo );
+        }
+
+       final TimingPoints tp = orb.getTimerManager().points() ;
        try {
-           CorbaContactInfo corbaContactInfo = (CorbaContactInfo) contactInfo;
-           orb = (ORB)contactInfo.getBroker();
-           tp = orb.getTimerManager().points() ;
            tp.enter_totalRequest() ;
 
-           if (orb.subcontractDebugFlag) {
-               dprint(".beginRequest->: op/" + opName);
-           }
-
-           //
            // Portable Interceptor initialization.
-           //
            orb.getPIHandler().initiateClientPIRequest( false );
 
-           //
-           // Connection.
-           //
            CorbaConnection connection = null;
 
            // This locking is done so that multiple connections are not created
@@ -174,7 +173,6 @@
            synchronized (lock) {
                if (contactInfo.isConnectionBased()) {
                    try {
-
                        tp.enter_connectionSetup();
 
                        if (contactInfo.shouldCacheConnection()) {
@@ -184,22 +182,23 @@
 
                        if (connection != null) {
                            if (orb.subcontractDebugFlag) {
-                               dprint(".beginRequest: op/" + opName 
-                                   + ": Using cached connection: " + connection);
+                               dputil.info( "Using cached connection", connection);
                            }
                        } else {
                            connection = (CorbaConnection)
                            contactInfo.createConnection();
                            if (orb.subcontractDebugFlag) {
-                               dprint(".beginRequest: op/" + opName
-                                   + ": Using created connection: " + connection);
+                               dputil.info( "Using created connection", connection);
                            }
 
                            if (connection.shouldRegisterReadEvent()) {
-                               // REVISIT: cast
                                orb.getTransportManager().getSelector(0)
                                    .registerForEvent(connection.getEventHandler());
                                connection.setState("ESTABLISHED");
+
+                                if (orb.subcontractDebugFlag) {
+                                    dputil.info( "connection registered" ) ;
+                                }
                            }
 
                            // Do not do connection reclaim here since the connections
@@ -211,22 +210,24 @@
                                            .getOutboundConnectionCache(contactInfo);
                                connectionCache.stampTime(connection);
                                connectionCache.put(contactInfo, connection);
-                           //              connectionCache.reclaim();
-                           }
-                       }
-                   } finally {
+
+                                if (orb.subcontractDebugFlag) {
+                                    dputil.info( "connection cached" ) ;
+                                }
+                            }
+                        } 
+                    } finally {
                        tp.exit_connectionSetup();
                    }
-               }
-           }
+                }
+            }
 
            CorbaMessageMediator messageMediator = 
                (CorbaMessageMediator)contactInfo.createMessageMediator(
                    orb, contactInfo, connection, opName, isOneWay);
 
            if (orb.subcontractDebugFlag) {
-               dprint(".beginRequest: " + opAndId(messageMediator)
-               + ": created message mediator: " +  messageMediator);
+               dputil.info( "created message mediator", messageMediator);
            }
 
            // NOTE: Thread data so we can get the mediator in release reply
@@ -252,10 +253,8 @@
            OutputObject outputObject = contactInfo.createOutputObject(messageMediator);
 
            if (orb.subcontractDebugFlag) {
-               dprint(".beginRequest: " + opAndId(messageMediator)
-               + ": created output object: " + outputObject);
+               dputil.info( "created output object", outputObject );
            }
-
 
            // NOTE: Not necessary for oneways, but useful for debugging.
            // This must be done BEFORE message initialization since fragments
@@ -266,6 +265,9 @@
            synchronized (lock) {
                if (contactInfo.isConnectionBased()) {
                    if (contactInfo.shouldCacheConnection()) {
+                        if (orb.subcontractDebugFlag) {
+                            dputil.info( "reclaiming connections" );
+                        }
                        OutboundConnectionCache connectionCache = orb.getTransportManager()
                            .getOutboundConnectionCache(contactInfo);
                        connectionCache.reclaim();
@@ -281,8 +283,7 @@
                orb.getPIHandler().invokeClientPIStartingPoint();
            } catch( RemarshalException e ) {
                if (orb.subcontractDebugFlag) {
-                   dprint(".beginRequest: " + opAndId(messageMediator)
-                       + ": Remarshal");
+                   dputil.info( "Remarshal" ) ;
                }
 
                // NOTE: We get here because an interceptor raised ForwardRequest
@@ -300,8 +301,21 @@
                // Want to move that update to here.
                if (getContactInfoListIterator(orb).hasNext()) {
                    contactInfo = (ContactInfo)getContactInfoListIterator(orb).next();
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "RemarshalException: hasNext true", 
+                            "contact info", contactInfo ) ;
+                    }
+
+                    // Fix for 6763340: Complete the first attempt before starting another.
+                    orb.getPIHandler().makeCompletedClientRequest( 
+                        ReplyMessage.LOCATION_FORWARD, null ) ;
+                    orb.getPIHandler().cleanupClientPIRequest() ;
+
                    return beginRequest(self, opName, isOneWay, contactInfo);
                } else {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "RemarshalException: hasNext false" ) ;
+                    }
                    ORBUtilSystemException wrapper = 
                        orb.getLogWrapperTable().get_RPC_PROTOCOL_ORBUtil() ; 
                    throw wrapper.remarshalWithNowhereToGo();
@@ -310,8 +324,7 @@
 
            messageMediator.initializeMessage();
            if (orb.subcontractDebugFlag) {
-               dprint(".beginRequest: " + opAndId(messageMediator)
-                   + ": initialized message");
+               dputil.info( "initialized message");
            }
 
            tp.enter_clientEncoding();
@@ -320,7 +333,7 @@
 
        } finally {
            if (orb.subcontractDebugFlag) {
-               dprint(".beginRequest<-: op/" + opName);
+                dputil.exit() ;
            }
        }
     }
@@ -331,28 +344,22 @@
            ApplicationException, 
            org.omg.CORBA.portable.RemarshalException
     {
-       ORB orb = null;
-       TimingPoints tp = null;
-       CorbaMessageMediator messageMediator = null;
+        CorbaMessageMediator messageMediator = (CorbaMessageMediator)
+            outputObject.getMessageMediator();
+        ORB orb = (ORB) messageMediator.getBroker();
+        TimingPoints tp = orb.getTimerManager().points() ;
+        if (orb.subcontractDebugFlag) {
+            dputil.enter( "marshalingComplete", "self", self,
+                opAndId( messageMediator ) ) ;
+        }
+
        try {
-           messageMediator = (CorbaMessageMediator)
-               outputObject.getMessageMediator();
+           tp.exit_clientEncoding();
+           tp.enter_clientTransportAndWait();
 
-           orb = (ORB) messageMediator.getBroker();
-           tp = orb.getTimerManager().points() ;
-
-           tp.exit_clientEncoding();
-
-
-           if (orb.subcontractDebugFlag) {
-               dprint(".marshalingComplete->: " + opAndId(messageMediator));
-           }
-
-           tp.enter_clientTransportAndWait();
            InputObject inputObject = null ;
            try {
-               inputObject = 
-                   marshalingComplete1(orb, messageMediator);
+               inputObject = marshalingComplete1(orb, messageMediator);
            } finally {
                tp.exit_clientTransportAndWait();
            }
@@ -364,7 +371,7 @@
            tp.enter_clientDecoding() ;
 
            if (orb.subcontractDebugFlag) {
-               dprint(".marshalingComplete<-: " + opAndId(messageMediator));
+               dputil.exit();
            }
        }
     }
@@ -375,21 +382,17 @@
            ApplicationException, 
            org.omg.CORBA.portable.RemarshalException
     {
+        if (orb.subcontractDebugFlag) {
+            dputil.enter("marshalingComplete1", opAndId(messageMediator) ) ;
+        }
+
        try {
            messageMediator.finishSendingRequest();
 
+           return messageMediator.waitForResponse();
+       } catch (RuntimeException e) {
            if (orb.subcontractDebugFlag) {
-               dprint(".marshalingComplete: " + opAndId(messageMediator)
-                      + ": finished sending request");
-           }
-
-           return messageMediator.waitForResponse();
-
-       } catch (RuntimeException e) {
-
-           if (orb.subcontractDebugFlag) {
-               dprint(".marshalingComplete: " + opAndId(messageMediator)
-                      + ": exception: " + e.toString());
+               dputil.info( "exception", e.toString());
            }
 
            boolean retry  =
@@ -404,22 +407,44 @@
 
            if (retry) {
                if (newException == e) {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "Retry true; same exception" ) ;
+                    }
+
                    continueOrThrowSystemOrRemarshal(messageMediator,
                                                     new RemarshalException());
                } else {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "Retry true; new exception" ) ;
+                    }
+
                    continueOrThrowSystemOrRemarshal(messageMediator,
                                                     newException);
                }
            } else {
                // NOTE: Interceptor ending point will run in releaseReply.
-               if (newException instanceof RuntimeException)
+               if (newException instanceof RuntimeException) {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "Retry false; RuntimeException" ) ;
+                    }
+
                    throw (RuntimeException)newException ;
-               else 
+               } else {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "Retry false; other exception" ) ;
+                    }
+
                    // XXX Not sure what to do in this case, or if it is even possible.
                    throw e ;
-           }
+                }
+           } 
+
            return null; // for compiler
-       }
+       } finally {
+            if (orb.subcontractDebugFlag) {
+                dputil.exit();
+            }
+        }
     }
 
     protected InputObject processResponse(ORB orb, 
@@ -434,8 +459,7 @@
            orb.getLogWrapperTable().get_RPC_PROTOCOL_ORBUtil() ;
 
        if (orb.subcontractDebugFlag) {
-           dprint(".processResponse: " + opAndId(messageMediator)
-                  + ": response received");
+           dputil.enter("processResponse", opAndId(messageMediator) ) ;
        }
 
        tp.enter_processResponse() ;
@@ -443,6 +467,9 @@
            // We know for sure now that we've sent a message.
            // So OK to not send initial again.
            if (messageMediator.getConnection() != null) {
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "Non-null connection" ) ;
+                }
                ((CorbaConnection)messageMediator.getConnection())
                    .setPostInitialContexts();
            }
@@ -455,11 +482,17 @@
            Exception exception = null;
 
            if (messageMediator.isOneWay()) {
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "One way request" ) ;
+                }
                getContactInfoListIterator(orb)
                    .reportSuccess(messageMediator.getContactInfo());
                // Invoke Portable Interceptors with receive_other
                exception = orb.getPIHandler().invokeClientPIEndingPoint(
                    ReplyMessage.NO_EXCEPTION, exception );
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "One way request", "exception", exception ) ;
+                }
                continueOrThrowSystemOrRemarshal(messageMediator, exception);
                return null;
            }
@@ -472,12 +505,9 @@
            ((CDRInputObject)inputObject).performORBVersionSpecificInit();
 
            if (messageMediator.isSystemExceptionReply()) {
-
                SystemException se = messageMediator.getSystemExceptionReply();
-
                if (orb.subcontractDebugFlag) {
-                   dprint(".processResponse: " + opAndId(messageMediator)
-                          + ": received system exception: " + se);
+                   dputil.info( "received system exception", se);
                }
 
                boolean doRemarshal =
@@ -485,6 +515,9 @@
                        .reportException(messageMediator.getContactInfo(), se);
 
                if (doRemarshal) {
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "Do remarshal", se);
+                    }
                        
                    // Invoke Portable Interceptors with receive_exception:
                    exception = orb.getPIHandler().invokeClientPIEndingPoint(
@@ -493,6 +526,9 @@
                    // If PI did not change the exception, throw a
                    // Remarshal.
                    if( se == exception ) {
+                        if (orb.subcontractDebugFlag) {
+                            dputil.info( "Do remarshal: same exception");
+                        }
                        // exception = null is to maintain symmetry with
                        // GenericPOAClientSC.
                        exception = null;
@@ -500,6 +536,9 @@
                                                         new RemarshalException());
                        throw wrapper.statementNotReachable1() ;
                    } else {
+                        if (orb.subcontractDebugFlag) {
+                            dputil.info( "Do remarshal: new exception", exception );
+                        }
                        //  Otherwise, throw the exception PI wants thrown.
                        continueOrThrowSystemOrRemarshal(messageMediator,
                                                         exception);
@@ -508,6 +547,9 @@
                }
 
                // No retry, so see if was unknown.
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "NO remarshal", se);
+                }
 
                ServiceContexts contexts = 
                    messageMediator.getReplyServiceContexts();
@@ -520,9 +562,19 @@
                        Throwable unknown = usc.getUE() ;
                        UnknownException ue = new UnknownException(unknown);
 
+                        if (orb.subcontractDebugFlag) {
+                            dputil.info( "NO remarshal: UserException available", 
+                                unknown );
+                        }
+
                        // Invoke Portable Interceptors with receive_exception:
                        exception = orb.getPIHandler().invokeClientPIEndingPoint(
                            ReplyMessage.SYSTEM_EXCEPTION, ue );
+
+                        if (orb.subcontractDebugFlag) {
+                            dputil.info( "NO remarshal: UserException available: PI exception ", 
+                                exception );
+                        }
 
                        continueOrThrowSystemOrRemarshal(messageMediator, exception);
                        throw wrapper.statementNotReachable3() ;
@@ -531,10 +583,17 @@
 
                // It was not a comm failure nor unknown.
                // This is the general case.
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "general exception", se);
+                }
 
                // Invoke Portable Interceptors with receive_exception:
-               exception = orb.getPIHandler().invokeClientPIEndingPoint(
+               exception = orb.getPIHandler().invokeClientPIEndingPoint( // ### FIRST CALL
                    ReplyMessage.SYSTEM_EXCEPTION, se );
+
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "general exception: PI exception", exception );
+                }
 
                continueOrThrowSystemOrRemarshal(messageMediator, exception);
 
@@ -542,16 +601,14 @@
                // we should assert in case exception is null somehow.
                throw wrapper.statementNotReachable4() ;
            } else if (messageMediator.isUserExceptionReply()) {
-
-               if (orb.subcontractDebugFlag) {
-                   dprint(".processResponse: " + opAndId(messageMediator)
-                          + ": received user exception");
-               }
-
                getContactInfoListIterator(orb)
                    .reportSuccess(messageMediator.getContactInfo());
 
                String exceptionRepoId = peekUserExceptionId(inputObject);
+               if (orb.subcontractDebugFlag) {
+                   dputil.info( "received user exception", "exceptionRepoId", exceptionRepoId );
+               }
+
                Exception newException = null;
 
                if (messageMediator.isDIIRequest()) {
@@ -560,15 +617,24 @@
                    newException = orb.getPIHandler().invokeClientPIEndingPoint(
                                       ReplyMessage.USER_EXCEPTION, exception );
                    messageMediator.setDIIException(newException);
-                   
+
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "received user exception (DII)", "exception", exception,
+                            "newException", newException );
+                    }
                } else {
-                   ApplicationException appException =
-                       new ApplicationException(
-                           exceptionRepoId,
-                           (org.omg.CORBA.portable.InputStream)inputObject);
+                   ApplicationException appException = new ApplicationException(
+                        exceptionRepoId, (org.omg.CORBA.portable.InputStream)inputObject);
+
                    exception = appException;
+
                    newException = orb.getPIHandler().invokeClientPIEndingPoint(
                                       ReplyMessage.USER_EXCEPTION, appException );
+
+                    if (orb.subcontractDebugFlag) {
+                        dputil.info( "received user exception (not DII)", "exception", exception,
+                            "newException", newException );
+                    }
                }
 
                if (newException != exception) {
@@ -583,10 +649,8 @@
                return inputObject;
 
            } else if (messageMediator.isLocationForwardReply()) {
-
                if (orb.subcontractDebugFlag) {
-                   dprint(".processResponse: " + opAndId(messageMediator)
-                          + ": received location forward");
+                   dputil.info( "received location forward");
                }
                
                // NOTE: Expects iterator to update target IOR
@@ -613,10 +677,8 @@
                throw wrapper.statementNotReachable5() ;
 
            } else if (messageMediator.isDifferentAddrDispositionRequestedReply()){
-
                if (orb.subcontractDebugFlag) {
-                   dprint(".processResponse: " + opAndId(messageMediator)
-                          + ": received different addressing dispostion request");
+                   dputil.info( "received different addressing dispostion request");
                }
 
                // Set the desired target addressing disposition.
@@ -643,10 +705,8 @@
                                                 new RemarshalException());
                throw wrapper.statementNotReachable6() ;
            } else /* normal response */ {
-
                if (orb.subcontractDebugFlag) {
-                   dprint(".processResponse: " + opAndId(messageMediator)
-                          + ": received normal response");
+                   dputil.info( "received normal response");
                }
 
                getContactInfoListIterator(orb)
@@ -665,6 +725,9 @@
            }
         } finally {
            tp.exit_processResponse() ;
+            if (orb.subcontractDebugFlag) {
+                dputil.exit() ;
+            }
        }
     }
 
@@ -673,68 +736,64 @@
     // of one of these two types.  This is a utility method for
     // the above invoke code which must do this numerous times.
     // If the exception is null, no exception is thrown.
-    //
     // Note that this code is duplicated in GenericPOAClientSC.java
     protected void continueOrThrowSystemOrRemarshal(
         CorbaMessageMediator messageMediator, Exception exception)
         throws 
            SystemException, RemarshalException
     {
+        final ORB orb = (ORB) messageMediator.getBroker();
 
-       ORB orb = (ORB) messageMediator.getBroker();
+        if (orb.subcontractDebugFlag) {
+            dputil.enter( "continueOrThrowSystemOrRemarshal", "exception", exception ) ;
+        }
 
-        if( exception == null ) {
+        try {
+            if ( exception == null ) {
+                // do nothing.
+            } else if( exception instanceof RemarshalException ) {
+                // REVISIT - unify with PI handling
+                orb.getInvocationInfo().setIsRetryInvocation(true);
 
-            // do nothing.
+                // NOTE - We must unregister the waiter NOW for this request
+                // since the retry will result in a new request id.  Therefore
+                // the old request id would be lost and we would have a memory
+                // leak in the responseWaitingRoom.
+                unregisterWaiter(orb);
 
-        } else if( exception instanceof RemarshalException ) {
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "throwing Remarshal" );
+                }
 
-           // REVISIT - unify with PI handling
-           orb.getInvocationInfo().setIsRetryInvocation(true);
+                throw (RemarshalException)exception;
 
-           // NOTE - We must unregister the waiter NOW for this request
-           // since the retry will result in a new request id.  Therefore
-           // the old request id would be lost and we would have a memory
-           // leak in the responseWaitingRoom.
-           unregisterWaiter(orb);
+            } else {
+                if (orb.subcontractDebugFlag) {
+                    dputil.info( "throwing exception", exception);
+                }
 
-           if (orb.subcontractDebugFlag) {
-               dprint(".continueOrThrowSystemOrRemarshal: "
-                      + opAndId(messageMediator)
-                      + ": throwing Remarshal");
-           }
-
-            throw (RemarshalException)exception;
-
-        } else {
-
-           if (orb.subcontractDebugFlag) {
-               dprint(".continueOrThrowSystemOrRemarshal: "
-                      + opAndId(messageMediator)
-                      + ": throwing sex:" 
-                      + exception);
-           }
-
-            throw (SystemException)exception;
+                throw (SystemException)exception;
+            }
+        } finally {
+            if (orb.subcontractDebugFlag) {
+                dputil.exit() ;
+            }
         }
     }
 
-    protected CorbaContactInfoListIterator  getContactInfoListIterator(ORB orb)
-    {
+    protected CorbaContactInfoListIterator  getContactInfoListIterator(ORB orb) {
        return (CorbaContactInfoListIterator)
            ((CorbaInvocationInfo)orb.getInvocationInfo())
                .getContactInfoListIterator();
     }
 
-    protected void registerWaiter(CorbaMessageMediator messageMediator)
-    {
+    protected void registerWaiter(CorbaMessageMediator messageMediator) {
        if (messageMediator.getConnection() != null) {
            messageMediator.getConnection().registerWaiter(messageMediator);
        }
     }
 
-    protected void unregisterWaiter(ORB orb)
-    {
+    protected void unregisterWaiter(ORB orb) {
        MessageMediator messageMediator =
            orb.getInvocationInfo().getMessageMediator();
        if (messageMediator!=null && messageMediator.getConnection() != null) {
@@ -745,8 +804,7 @@
        }
     }
 
-    protected void addServiceContexts(CorbaMessageMediator messageMediator)
-    {
+    protected void addServiceContexts(CorbaMessageMediator messageMediator) {
        ORB orb = (ORB)messageMediator.getBroker();
        CorbaConnection c = (CorbaConnection) messageMediator.getConnection();
        GIOPVersion giopVersion = messageMediator.getGIOPVersion();
@@ -887,11 +945,9 @@
        TimingPoints tp = orb.getTimerManager().points() ;
 
        try {
-
            tp.exit_clientDecoding();
-
            if (orb.subcontractDebugFlag) {
-               dprint(".endRequest->:");
+               dputil.enter("endRequest");
            }
 
            // Note: the inputObject may be null if an error occurs
@@ -900,12 +956,10 @@
 
            MessageMediator messageMediator =
                orb.getInvocationInfo().getMessageMediator();
-           if (messageMediator != null)
-            {
+           if (messageMediator != null) {
                ORBUtility.popEncVersionFromThreadLocalState();
 
-                if (messageMediator.getConnection() != null) 
-                {
+                if (messageMediator.getConnection() != null) {
                     ((CorbaMessageMediator)messageMediator)
                               .sendCancelRequestIfFinalFragmentNotSent();
                 }
@@ -939,26 +993,24 @@
            // exceptions during stream marshaling.  More generally, exceptions
            // that occur in the ORB after send_request (which includes
            // after returning from _request) before _invoke:
-           orb.getPIHandler().cleanupClientPIRequest();
+           orb.getPIHandler().cleanupClientPIRequest(); // ### SECOND CALL
            
            // REVISIT: Early replies?
        } catch (IOException ex) { 
             // See CDRInput/OutputObject.close() for more info.
             // This won't result in a Corba error if an IOException happens.
-           if (orb.subcontractDebugFlag)
-            {
-               dprint(".endRequest: ignoring IOException - " + ex.toString());
+           if (orb.subcontractDebugFlag) {
+               dputil.info("ignoring IOException", ex );
             }
        } finally {
            tp.exit_totalRequest() ;
            if (orb.subcontractDebugFlag) {
-               dprint(".endRequest<-:");
+               dputil.exit() ;
            }
        }
     }
 
-    protected void performCodeSetNegotiation(CorbaMessageMediator messageMediator)
-    {
+    protected void performCodeSetNegotiation(CorbaMessageMediator messageMediator) {
        CorbaConnection conn = (CorbaConnection) messageMediator.getConnection();
         if (conn == null)
             return ;
@@ -1003,9 +1055,8 @@
         }
     }
 
-    protected void addCodeSetServiceContext(CorbaConnection conn,
-                                          ServiceContexts ctxs,
-                                          GIOPVersion giopVersion) {
+    protected void addCodeSetServiceContext(CorbaConnection conn, 
+        ServiceContexts ctxs, GIOPVersion giopVersion) {
 
         // REVISIT.  OMG issue 3318 concerning sending the code set
         // service context more than once was deemed too much for the
@@ -1035,6 +1086,7 @@
             // Get the negotiated code sets (if any) out of the connection
             codeSetCtx = conn.getCodeSetContext();
         }
+        
         // Either we shouldn't send the code set service context, or
         // for some reason, the connection doesn't have its code sets.
         // Perhaps the server didn't include them in the IOR.  Uses
@@ -1047,8 +1099,7 @@
        ctxs.put(cssc);
     }    
 
-    protected String peekUserExceptionId(InputObject inputObject)
-    {
+    protected String peekUserExceptionId(InputObject inputObject) {
        CDRInputObject cdrInputObject = (CDRInputObject) inputObject;
        // REVISIT - need interface for mark/reset
         cdrInputObject.mark(Integer.MAX_VALUE);
@@ -1057,13 +1108,7 @@
         return result;
     }                     
 
-    protected void dprint(String msg)
-    {
-       ORBUtility.dprint("CorbaClientRequestDispatcherImpl", msg);
-    }
-
-    protected String opAndId(CorbaMessageMediator mediator)
-    {
+    protected String opAndId(CorbaMessageMediator mediator) {
        return ORBUtility.operationNameAndRequestId(mediator);
     }
 }
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/spi/orb/ORB.java
--- a/src/share/classes/com/sun/corba/ee/spi/orb/ORB.java       Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/spi/orb/ORB.java       Mon Jul 06 12:05:55 2009 -0700
@@ -172,7 +172,7 @@
     public boolean streamFormatVersionDebugFlag = false ;
     public boolean valueHandlerDebugFlag = false ;
     public boolean orbLifecycleDebugFlag = false ;
-    
+
     private LogWrapperTable logWrapperTable ;
 
     private static LogWrapperTable staticLogWrapperTable = 
diff -r 4074e79c320a src/share/classes/com/sun/corba/ee/spi/protocol/PIHandler.java
--- a/src/share/classes/com/sun/corba/ee/spi/protocol/PIHandler.java    Fri May 15 17:40:34 2009 -0700
+++ b/src/share/classes/com/sun/corba/ee/spi/protocol/PIHandler.java    Mon Jul 06 12:05:55 2009 -0700
@@ -155,6 +155,27 @@
         int replyStatus, Exception exception ) ;
 
     /**
+     * Called when a retry is needed after initiateClientPIRequest but 
+     * before invokeClientPIRequest.  In this case, we need to properly
+     * balance initiateClientPIRequest/cleanupClientPIRequest calls,
+     * but WITHOUT extraneous calls to invokeClientPIEndingPoint
+     * (see bug 6763340).
+     *
+     * @param replyStatus One of the constants in iiop.messages.ReplyMessage
+     *     indicating which reply status to set.
+     * @param exception The exception before ending interception points have
+     *     been invoked, or null if no exception at the moment.
+     * @return The exception to be thrown, after having gone through
+     *     all ending points, or null if there is no exception to be
+     *     thrown.  Note that this exception can be either the same or
+     *     different from the exception set using setClientPIException.
+     *     There are four possible return types: null (no exception),
+     *     SystemException, UserException, or RemarshalException.
+     */
+    Exception makeCompletedClientRequest(
+        int replyStatus, Exception exception ) ;
+
+    /**
      * Invoked when a request is about to be created.  Must be called before
      * any of the setClientPI* methods so that a new info object can be
      * prepared for information collection.
